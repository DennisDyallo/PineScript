//@version=5
// @description Volume analysis utilities for institutional trading indicators
// @version 1.1.0 (2025-01-18)
//
// CHANGELOG:
// v1.1.0: Added standardized volume threshold functions (2025-01-18)
//   - VolumeThresholds type: Structured threshold data (low, medium, high)
//   - isVolumeSpike(): Simple threshold check with default 1.5x
//   - getVolumeTier(): Multi-tier classification (0=normal, 1=elevated, 2=high, 3=extreme)
//   - getRegimeAdjustedThresholds(): Volatility-adaptive thresholds (±15-20% based on ATR)
//   - getAssetAdjustedThresholds(): Asset class adjustments (crypto -15%, futures -10%)
//   - Standard thresholds: 1.3x (elevated), 1.5x (high), 2.0x (extreme)
//   - Research-backed: Elder (2002), Harris (2003), Murphy (1999)
//
// v1.0.0: Initial release
//   - calculateVolumeMetrics(): Comprehensive volume analysis
//   - VolumeMetrics type with relativeVolume, efficiency, score
//   - Basic threshold and divergence detection
library("VolumeAnalysis")

// NOTE: This library will import CoreMath after it's published
// For now, we'll include safe division inline

// ============================================================================
// INLINE SAFE MATH (temporary until CoreMath library is published)
// ============================================================================

// Safe division with NA protection
_safeDivide(float numerator, float denominator, float defaultValue = 1.0) =>
    denominator > 0 and not na(denominator) and not na(numerator) ?
         numerator / denominator :
         defaultValue

// Safe range calculation
_safeRange(float priceRange, float closeVal, float minPercent = 0.001) =>
    minAllowed = closeVal * minPercent
    math.max(priceRange, minAllowed)

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

// @type Volume metrics and analysis data
// @field relativeVolume Current volume divided by average volume
// @field volumeEfficiency Volume divided by price range (volume per point moved)
// @field efficiencyRatio Current efficiency divided by average efficiency
// @field volumeScore Normalized score 0-50 based on relative volume
export type VolumeMetrics
    float relativeVolume
    float volumeEfficiency
    float efficiencyRatio
    float volumeScore

// @type Volume threshold data for tier classification
// @field low Threshold for elevated volume (Tier 1, default: 1.3x)
// @field medium Threshold for high volume (Tier 2, default: 1.5x)
// @field high Threshold for extreme volume (Tier 3, default: 2.0x)
export type VolumeThresholds
    float low
    float medium
    float high

// ============================================================================
// VOLUME CALCULATION FUNCTIONS
// ============================================================================
// @function Calculates comprehensive volume metrics for current bar
// @param lookback Period for average calculations (default: 20)
// @param minRangePercent Minimum price range as % of close to prevent division errors (default: 0.001 = 0.1%)
// @returns VolumeMetrics object with all volume analysis data
// @example volMetrics = calculateVolumeMetrics(20) => Standard 20-period volume analysis
export calculateVolumeMetrics(simple int lookback = 20, simple float minRangePercent = 0.001) =>

    // Calculate relative volume (volume vs average volume)
    avgVolume = ta.sma(volume, lookback)
    relVol = _safeDivide(volume, avgVolume, 1.0)

    // Calculate volume efficiency (volume / price range)
    priceRange = high - low
    safeRange = _safeRange(priceRange, close, minRangePercent)
    volEfficiency = volume / safeRange

    // Calculate efficiency ratio (current vs average efficiency)
    avgVolEfficiency = ta.sma(volEfficiency, lookback)
    effRatio = _safeDivide(volEfficiency, avgVolEfficiency, 1.0)

    // Calculate volume score (0-50 range, normalized)
    // Above-average volume (relVol > 1.0) scores higher
    // Score = (relVol - 1.0) * 25, clamped to 0-50
    volScore = math.min(50, math.max(0, (relVol - 1.0) * 25.0))

    // Return volume metrics
    VolumeMetrics.new(relVol, volEfficiency, effRatio, volScore)

// @function Simplified volume metrics with standard parameters (convenience wrapper)
// @returns VolumeMetrics object with 20-period lookback
export calculateVolumeMetricsSimple() =>
    calculateVolumeMetrics(20, 0.001)

// ============================================================================
// VOLUME THRESHOLD DETECTION
// ============================================================================

// @function Checks if current volume exceeds threshold
// @param metrics VolumeMetrics object
// @param threshold Relative volume threshold (default: 1.5 = 50% above average)
// @returns True if volume is above threshold
export isVolumeAboveThreshold(VolumeMetrics metrics, float threshold = 1.5) =>
    metrics.relativeVolume > threshold

// @function Checks if volume efficiency exceeds threshold
// @param metrics VolumeMetrics object
// @param threshold Efficiency ratio threshold (default: 1.5)
// @returns True if efficiency is above threshold
export isEfficiencyAboveThreshold(VolumeMetrics metrics, float threshold = 1.5) =>
    metrics.efficiencyRatio > threshold

// ============================================================================
// STANDARDIZED VOLUME THRESHOLD FUNCTIONS (v1.1)
// ============================================================================

// @function Checks if current volume is a spike (simple threshold check)
// @param relativeVolume Relative volume ratio from calculateVolumeMetrics()
// @param threshold Minimum ratio for spike (default: 1.5 = 150% of average)
// @returns True if volume exceeds threshold
// @example isVolumeSpike(volMetrics.relativeVolume, 1.5) => True if volume is 1.5x or higher
export isVolumeSpike(float relativeVolume, float threshold = 1.5) =>
    relativeVolume >= threshold

// @function Classifies volume into tiers for graduated response
// @param relativeVolume Relative volume ratio from calculateVolumeMetrics()
// @param lowThreshold Minimum for "elevated" tier (default: 1.3 = 130%)
// @param mediumThreshold Minimum for "high" tier (default: 1.5 = 150%)
// @param highThreshold Minimum for "extreme" tier (default: 2.0 = 200%)
// @returns Tier: 0=normal, 1=elevated, 2=high, 3=extreme
// @example getVolumeTier(volMetrics.relativeVolume) => Returns 0-3 based on standard thresholds
export getVolumeTier(float relativeVolume, float lowThreshold = 1.3, float mediumThreshold = 1.5, float highThreshold = 2.0) =>
    tier = relativeVolume >= highThreshold ? 3 :
           relativeVolume >= mediumThreshold ? 2 :
           relativeVolume >= lowThreshold ? 1 :
           0
    tier

// @function Calculates regime-adjusted volume thresholds based on volatility
// @param atrRatio Current ATR divided by average ATR (from lib_regime_detection)
// @param baseThresholdLow Base threshold for elevated tier (default: 1.3)
// @param baseThresholdMed Base threshold for high tier (default: 1.5)
// @param baseThresholdHigh Base threshold for extreme tier (default: 2.0)
// @returns VolumeThresholds object with adjusted thresholds
// @example In high volatility (atrRatio=1.5): thresholds raised by 20% to [1.56, 1.8, 2.4]
// @example In low volatility (atrRatio=0.7): thresholds lowered by 15% to [1.1, 1.3, 1.7]
// @note High volatility naturally brings higher volume → raise thresholds to maintain significance
// @note Low volatility has lower volume baseline → lower thresholds to detect subtle moves
export getRegimeAdjustedThresholds(float atrRatio, float baseThresholdLow = 1.3, float baseThresholdMed = 1.5, float baseThresholdHigh = 2.0) =>

    // Determine multiplier based on volatility regime
    // High vol (atrRatio > 1.3): raise thresholds +20%
    // Low vol (atrRatio < 0.7): lower thresholds -15%
    // Normal vol (0.7 to 1.3): no adjustment
    multiplier = atrRatio > 1.3 ? 1.2 :      // High volatility: +20%
                 atrRatio < 0.7 ? 0.85 :     // Low volatility: -15%
                 1.0                          // Normal volatility: no change

    // Apply multiplier to all thresholds
    adjustedLow = baseThresholdLow * multiplier
    adjustedMed = baseThresholdMed * multiplier
    adjustedHigh = baseThresholdHigh * multiplier

    // Return as VolumeThresholds object
    VolumeThresholds.new(adjustedLow, adjustedMed, adjustedHigh)

// @function Adjusts volume thresholds for different asset classes
// @param assetType Asset class: "stock", "crypto", or "futures"
// @param baseThresholdLow Base threshold for elevated tier (default: 1.3)
// @param baseThresholdMed Base threshold for high tier (default: 1.5)
// @param baseThresholdHigh Base threshold for extreme tier (default: 2.0)
// @returns VolumeThresholds object with asset-adjusted thresholds
// @example For crypto (24/7 trading): thresholds lowered by 15% to [1.1, 1.3, 1.7]
// @example For futures (23hr trading): thresholds lowered by 10% to [1.2, 1.4, 1.8]
// @example For stocks (6.5hr trading): no adjustment, standard [1.3, 1.5, 2.0]
// @note Crypto/futures trade 24/7 → volume spread over more time → lower spike thresholds
// @note Stocks trade 6.5hr RTH → volume concentrated → standard thresholds apply
export getAssetAdjustedThresholds(simple string assetType, float baseThresholdLow = 1.3, float baseThresholdMed = 1.5, float baseThresholdHigh = 2.0) =>

    // Determine multiplier based on asset class trading hours
    // Crypto: 24hr trading → lower thresholds by 15%
    // Futures: 23hr trading → lower thresholds by 10%
    // Stock: 6.5hr RTH → standard thresholds
    multiplier = assetType == "crypto" ? 0.85 :    // Crypto: -15%
                 assetType == "futures" ? 0.9 :    // Futures: -10%
                 1.0                                // Stocks: no change

    // Apply multiplier to all thresholds
    adjustedLow = baseThresholdLow * multiplier
    adjustedMed = baseThresholdMed * multiplier
    adjustedHigh = baseThresholdHigh * multiplier

    // Return as VolumeThresholds object
    VolumeThresholds.new(adjustedLow, adjustedMed, adjustedHigh)

// ============================================================================
// VOLUME-WEIGHTED CALCULATIONS
// ============================================================================

// @function Calculates volume weight for current bar (sqrt dampening)
// @param metrics VolumeMetrics object
// @returns Volume weight using sqrt to dampen outliers
// @example weight = calculateVolumeWeight(metrics) => 1.0 for avg volume, higher for elevated volume
export calculateVolumeWeight(VolumeMetrics metrics) =>
    // Use square root to dampen extreme volume spikes
    // relVol = 4.0 (4× avg) => weight = 2.0 (sqrt dampening)
    // relVol = 1.0 (avg) => weight = 1.0
    math.sqrt(metrics.relativeVolume)

// @function Calculates volume-weighted touch count increment
// @param metrics VolumeMetrics object
// @returns Float increment for touch counting (1.0 for avg volume, higher for elevated)
export calculateVolumeWeightedIncrement(VolumeMetrics metrics) =>
    // Standard touch count increment is volume-weighted
    // Average volume = 1.0 increment
    // 2× average volume = 1.414 increment (sqrt(2))
    // 4× average volume = 2.0 increment (sqrt(4))
    calculateVolumeWeight(metrics)

// ============================================================================
// VOLUME DIVERGENCE DETECTION
// ============================================================================

// @function Detects price/volume divergence
// @param priceChange Price change over period
// @param metrics VolumeMetrics object
// @param threshold Divergence threshold (default: 0.5)
// @returns True if divergence detected (price moves but volume doesn't, or vice versa)
export detectVolumeDivergence(float priceChange, VolumeMetrics metrics, float threshold = 0.5) =>
    // Price increasing but volume decreasing = bearish divergence
    // Price decreasing but volume increasing = bullish divergence
    priceMagnitude = math.abs(priceChange)
    volumeDelta = metrics.relativeVolume - 1.0

    // Divergence if price and volume move in opposite directions
    (priceChange > threshold and volumeDelta < -threshold) or (priceChange < -threshold and volumeDelta > threshold)

// ============================================================================
// VOLUME REGIME CLASSIFICATION
// ============================================================================

// @function Classifies volume regime
// @param metrics VolumeMetrics object
// @returns String: "High Vol", "Normal Vol", "Low Vol"
export classifyVolumeRegime(VolumeMetrics metrics) =>
    metrics.relativeVolume > 1.5 ? "High Vol" : metrics.relativeVolume < 0.7 ? "Low Vol" : "Normal Vol"

// @function Gets volume regime color for visualization
// @param metrics VolumeMetrics object
// @returns Color: green for high, gray for normal, red for low
export getVolumeColor(VolumeMetrics metrics) =>
    metrics.relativeVolume > 1.5 ? color.new(color.green, 70) : metrics.relativeVolume < 0.7 ? color.new(color.red, 70) : color.new(color.gray, 70)