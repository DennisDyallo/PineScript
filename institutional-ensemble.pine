//@version=5
indicator(title="Institutional Detection Ensemble", shorttitle="Inst Ensemble", overlay=false, precision=0, max_bars_back=500)

// ============================================================================
// ENSEMBLE INDICATOR: COMBINES ALL THREE INSTITUTIONAL ALGORITHMS
// ============================================================================
// Weighted combination of:
// 1. Volume Efficiency & Absorption (25%)
// 2. Multi-Timeframe Convergence (35%)
// 3. Bayesian Regime Classifier (40%)
// ============================================================================

// ============================= INPUTS =======================================

// Ensemble Weighting
weight_efficiency = input.float(0.25, "Weight: Volume Efficiency", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_mtf = input.float(0.35, "Weight: MTF Convergence", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_bayesian = input.float(0.40, "Weight: Bayesian", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")

// General Settings
scoreThreshold = input.int(70, "Ensemble Score Threshold", minval=50, maxval=90, group="Scoring")
enableAlgo1 = input.bool(true, "Enable Algorithm 1 (Efficiency)", group="Algorithm Selection")
enableAlgo2 = input.bool(true, "Enable Algorithm 2 (MTF)", group="Algorithm Selection")
enableAlgo3 = input.bool(true, "Enable Algorithm 3 (Bayesian)", group="Algorithm Selection")

// Visualization
showTable = input.bool(true, "Show Ensemble Table", group="Visualization")
showComponentScores = input.bool(true, "Show Individual Algorithm Scores", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")

// ============================================================================
// ALGORITHM 1: VOLUME EFFICIENCY & ABSORPTION
// ============================================================================

volumeLookback1 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 1: Efficiency")
volumeThreshold1 = input.float(1.5, "Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group="Algo 1: Efficiency")
efficiencyThreshold1 = input.float(1.3, "Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Algo 1: Efficiency")

// Calculations with NA protection
avgVolume1 = ta.sma(volume, volumeLookback1)
relativeVolume1 = avgVolume1 > 0 and not na(avgVolume1) ? volume / avgVolume1 : 1.0
volumeScore1 = math.min(50, math.max(0, (relativeVolume1 - 1) * 25))

priceRange1 = high - low
avgPriceRange1 = ta.sma(priceRange1, volumeLookback1)
minRange1 = close * 0.0001
volumeEfficiency1 = priceRange1 > minRange1 ? volume / priceRange1 : volume / minRange1
avgVolumeEfficiency1 = ta.sma(volumeEfficiency1, volumeLookback1)
efficiencyRatio1 = avgVolumeEfficiency1 > 0 and not na(avgVolumeEfficiency1) ? volumeEfficiency1 / avgVolumeEfficiency1 : 1.0
efficiencyScore1 = efficiencyRatio1 > efficiencyThreshold1 and efficiencyRatio1 < 100 ? math.min(30, (efficiencyRatio1 - 1) * 15) : 0.0

upperWick1 = high - math.max(open, close)
lowerWick1 = math.min(open, close) - low
totalWickSize1 = upperWick1 + lowerWick1
wickRatio1 = priceRange1 > minRange1 ? totalWickSize1 / priceRange1 : 0.0
wickScore1 = wickRatio1 > 0.3 ? math.min(20, wickRatio1 * 40) : 0.0

closePosition1 = priceRange1 > minRange1 ? (close - low) / priceRange1 : 0.5
controlScore1 = 0.0
if closePosition1 >= 0.4 and closePosition1 <= 0.6 and relativeVolume1 > 1.5
    controlScore1 := 10.0
else if closePosition1 > 0.7 and relativeVolume1 > 2.0
    controlScore1 := 5.0

algo1_score = enableAlgo1 ? math.min(100, volumeScore1 + efficiencyScore1 + wickScore1 + controlScore1) : 0.0
algo1_type = closePosition1 >= 0.4 and closePosition1 <= 0.6 ? "Accumulation" : "Distribution"

// ============================================================================
// ALGORITHM 2: MULTI-TIMEFRAME CONVERGENCE
// ============================================================================

// Auto-detect higher timeframes
getHigherTimeframe(baseTF) =>
    tfInMinutes = timeframe.in_seconds(baseTF) / 60
    string result = ""
    if tfInMinutes <= 1
        result := "5"
    else if tfInMinutes <= 5
        result := "15"
    else if tfInMinutes <= 15
        result := "60"
    else if tfInMinutes <= 60
        result := "240"
    else if tfInMinutes < 1440
        result := "D"
    else if baseTF == "D"
        result := "W"
    else
        result := "M"
    result

getSecondHigherTimeframe(baseTF) =>
    firstHTF = getHigherTimeframe(baseTF)
    getHigherTimeframe(firstHTF)

higherTF1 = getHigherTimeframe(timeframe.period)
higherTF2 = getSecondHigherTimeframe(timeframe.period)

volumeLookback2 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 2: MTF")
mtfVolumeThreshold = input.float(1.5, "MTF Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group="Algo 2: MTF")

// Current timeframe with NA protection
currentVolume2 = volume
currentAvgVolume2 = ta.sma(volume, volumeLookback2)
currentRelVol2 = currentAvgVolume2 > 0 and not na(currentAvgVolume2) ? currentVolume2 / currentAvgVolume2 : 1.0

// Higher timeframes with NA protection
[htf1Volume, htf1AvgVolume] = request.security(syminfo.tickerid, higherTF1, [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)
htf1RelVol = htf1AvgVolume > 0 and not na(htf1AvgVolume) and not na(htf1Volume) ? htf1Volume / htf1AvgVolume : 1.0

[htf2Volume, htf2AvgVolume] = request.security(syminfo.tickerid, higherTF2, [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)
htf2RelVol = htf2AvgVolume > 0 and not na(htf2AvgVolume) and not na(htf2Volume) ? htf2Volume / htf2AvgVolume : 1.0

// Scoring
convergenceScore2 = 0.0
if currentRelVol2 > mtfVolumeThreshold and htf1RelVol > mtfVolumeThreshold and htf2RelVol > mtfVolumeThreshold
    convergenceScore2 := 40.0
else if (currentRelVol2 > mtfVolumeThreshold and htf1RelVol > mtfVolumeThreshold) or (htf1RelVol > mtfVolumeThreshold and htf2RelVol > mtfVolumeThreshold)
    convergenceScore2 := 25.0

volumePatternScore2 = htf2RelVol > htf1RelVol and htf1RelVol > currentRelVol2 and convergenceScore2 > 20 ? 20.0 : 0.0

currentRange2 = (high - low) / close
avgRange2 = ta.sma(currentRange2, volumeLookback2)
rangeRatio2 = avgRange2 > 0 and not na(avgRange2) ? currentRange2 / avgRange2 : 1.0

priceScore2 = 0.0
algo2_pattern = ""
if rangeRatio2 < 1.2 and convergenceScore2 > 20
    priceScore2 := 30.0
    algo2_pattern := "Accumulation"
else if rangeRatio2 > 1.2 and convergenceScore2 > 20
    priceScore2 := 20.0
    algo2_pattern := "Distribution"

htf1Close = request.security(syminfo.tickerid, higherTF1, close, lookahead=barmerge.lookahead_off)
htf1SMA = request.security(syminfo.tickerid, higherTF1, ta.sma(close, 50), lookahead=barmerge.lookahead_off)
htf1Trend = not na(htf1Close) and not na(htf1SMA) and htf1Close > htf1SMA
trendScore2 = htf1Trend and convergenceScore2 > 20 ? 10.0 : 0.0

algo2_score = enableAlgo2 ? math.min(100, convergenceScore2 + volumePatternScore2 + priceScore2 + trendScore2) : 0.0

// ============================================================================
// ALGORITHM 3: BAYESIAN REGIME CLASSIFIER
// ============================================================================

regimeLength3 = input.int(100, "Regime Length", minval=50, maxval=200, group="Algo 3: Bayesian")
atrLength3 = input.int(14, "ATR Length", minval=7, maxval=50, group="Algo 3: Bayesian")

// Regime detection with NA protection
currentATR3 = ta.atr(atrLength3)
avgATR3 = ta.sma(ta.atr(atrLength3), regimeLength3)
atrRatio3 = avgATR3 > 0 and not na(avgATR3) ? currentATR3 / avgATR3 : 1.0

isHighVol3 = atrRatio3 > 1.3
isLowVol3 = atrRatio3 < 0.7

[diPlus3, diMinus3, adxValue3] = ta.dmi(14, 14)
isTrending3 = adxValue3 > 25
isRanging3 = adxValue3 < 20

regime3 = ""
if isTrending3 and isHighVol3
    regime3 := "TrendHighVol"
else if isTrending3 and isLowVol3
    regime3 := "TrendLowVol"
else if isRanging3 and isHighVol3
    regime3 := "RangeHighVol"
else if isRanging3 and isLowVol3
    regime3 := "RangeLowVol"
else
    regime3 := "Neutral"

priorProbability3 = switch regime3
    "RangeLowVol" => 0.40
    "TrendLowVol" => 0.30
    "RangeHighVol" => 0.25
    "TrendHighVol" => 0.15
    => 0.20

// Feature detection with NA protection
avgVolume3 = ta.sma(volume, 20)
highVolume3 = avgVolume3 > 0 and not na(avgVolume3) and volume > (avgVolume3 * 2.0)

minRange3 = close * 0.0001
priceRange3 = high - low
volumeEfficiency3 = priceRange3 > minRange3 ? volume / priceRange3 : volume / minRange3
avgVolumeEfficiency3 = ta.sma(volumeEfficiency3, 20)
highEfficiency3 = avgVolumeEfficiency3 > 0 and not na(avgVolumeEfficiency3) and volumeEfficiency3 > (avgVolumeEfficiency3 * 1.5)

// Simplified likelihood (without intrabar for performance)
likelihoodGivenInst3 = 1.0
likelihoodGivenNotInst3 = 1.0

if regime3 == "RangeLowVol"
    if highVolume3
        likelihoodGivenInst3 *= 0.75
        likelihoodGivenNotInst3 *= 0.30
    if highEfficiency3
        likelihoodGivenInst3 *= 0.80
        likelihoodGivenNotInst3 *= 0.25
else if regime3 == "TrendHighVol"
    if highVolume3
        likelihoodGivenInst3 *= 0.85
        likelihoodGivenNotInst3 *= 0.60
    if highEfficiency3
        likelihoodGivenInst3 *= 0.60
        likelihoodGivenNotInst3 *= 0.40

numerator3 = likelihoodGivenInst3 * priorProbability3
denominator3 = (likelihoodGivenInst3 * priorProbability3) + (likelihoodGivenNotInst3 * (1 - priorProbability3))
posteriorProbability3 = denominator3 > 0 ? numerator3 / denominator3 : 0.0

signalCount3 = (highVolume3 ? 1 : 0) + (highEfficiency3 ? 1 : 0)
confidenceBoost3 = signalCount3 >= 2 ? 10.0 : 0.0

algo3_score = enableAlgo3 ? math.min(100, posteriorProbability3 * 100 + confidenceBoost3) : 0.0

// ============================================================================
// ENSEMBLE CALCULATION
// ============================================================================

// Normalize weights (handle edge case where all weights are 0)
totalWeight = weight_efficiency + weight_mtf + weight_bayesian
normWeight1 = totalWeight > 0 ? weight_efficiency / totalWeight : 1.0 / 3.0
normWeight2 = totalWeight > 0 ? weight_mtf / totalWeight : 1.0 / 3.0
normWeight3 = totalWeight > 0 ? weight_bayesian / totalWeight : 1.0 / 3.0

// Calculate weighted ensemble score
ensembleScore = (algo1_score * normWeight1) + (algo2_score * normWeight2) + (algo3_score * normWeight3)

// Agreement analysis
agreement = 0
if algo1_score >= scoreThreshold and enableAlgo1
    agreement += 1
if algo2_score >= scoreThreshold and enableAlgo2
    agreement += 1
if algo3_score >= scoreThreshold and enableAlgo3
    agreement += 1

// Confidence level
confidence = switch agreement
    3 => "High"
    2 => "Medium"
    1 => "Low"
    => "None"

// Classification
isInstitutional = ensembleScore >= scoreThreshold

institutionalType = ""
if isInstitutional
    if agreement >= 2
        if algo2_pattern == "Accumulation" or algo1_type == "Accumulation"
            institutionalType := "Accumulation"
        else if algo2_pattern == "Distribution"
            institutionalType := "Distribution"
        else
            institutionalType := "Mixed"
    else
        institutionalType := "Mixed"

// ============================= VISUALIZATION ================================

// Color gradient
ensembleColor = ensembleScore >= 70 ? color.new(color.green, 0) : ensembleScore >= 50 ? color.new(color.yellow, 0) : ensembleScore >= 30 ? color.new(color.orange, 0) : color.new(color.red, 0)

// Main ensemble score
plot(ensembleScore, "Ensemble Score", color=ensembleColor, style=plot.style_area, linewidth=3)

// Individual algorithm scores
plot(showComponentScores ? algo1_score : na, "Algo 1: Efficiency", color=color.new(color.blue, 50), linewidth=2)
plot(showComponentScores ? algo2_score : na, "Algo 2: MTF", color=color.new(color.purple, 50), linewidth=2)
plot(showComponentScores ? algo3_score : na, "Algo 3: Bayesian", color=color.new(color.fuchsia, 50), linewidth=2)

// Reference lines
hline(scoreThreshold, "Threshold", color=color.new(color.white, 50), linestyle=hline.style_dashed, linewidth=2)
hline(50, "Midline", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Background tint based on confidence
bgcolor(isInstitutional and confidence == "High" ? color.new(color.green, 85) : isInstitutional and confidence == "Medium" ? color.new(color.yellow, 90) : isInstitutional ? color.new(color.orange, 95) : na)

// Chart markers
plotshape(showMarkers and isInstitutional and confidence == "High" ? ensembleScore : na, "High Confidence", shape.circle, location.bottom, color.new(color.green, 0), size=size.normal)
plotshape(showMarkers and isInstitutional and confidence == "Medium" ? ensembleScore : na, "Medium Confidence", shape.circle, location.bottom, color.new(color.yellow, 0), size=size.small)

// ============================= ENSEMBLE TABLE ===============================

if showTable
    var table ensembleTable = table.new(position.top_right, 2, 14, border_width=1)

    if barstate.islast
        // Header
        table.cell(ensembleTable, 0, 0, "ENSEMBLE INSTITUTIONAL DETECTION", text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
        table.merge_cells(ensembleTable, 0, 0, 1, 0)

        // Ensemble Score
        table.cell(ensembleTable, 0, 1, "Ensemble Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 1, str.tostring(math.round(ensembleScore, 0)), text_color=color.white, bgcolor=color.new(ensembleColor, 50), text_size=size.normal)

        table.cell(ensembleTable, 0, 2, "Confidence:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        confColor = confidence == "High" ? color.lime : confidence == "Medium" ? color.yellow : color.orange
        table.cell(ensembleTable, 1, 2, confidence, text_color=confColor, bgcolor=color.new(color.gray, 70), text_size=size.small)

        table.cell(ensembleTable, 0, 3, "Type:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 3, institutionalType, text_color=color.white, bgcolor=color.new(ensembleColor, 50), text_size=size.small)

        table.cell(ensembleTable, 0, 4, "Agreement:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 4, str.tostring(agreement) + " / 3 algos", text_color=agreement >= 2 ? color.lime : color.orange, bgcolor=color.new(color.gray, 70), text_size=size.small)

        // Individual Algorithm Scores
        table.cell(ensembleTable, 0, 5, "Algorithm Scores:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(ensembleTable, 0, 5, 1, 5)

        algo1Check = algo1_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 6, "1. Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 6, algo1Check + " " + str.tostring(math.round(algo1_score, 0)), text_color=algo1_score >= scoreThreshold ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        algo2Check = algo2_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 7, "2. MTF:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 7, algo2Check + " " + str.tostring(math.round(algo2_score, 0)), text_color=algo2_score >= scoreThreshold ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        algo3Check = algo3_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 8, "3. Bayesian:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 8, algo3Check + " " + str.tostring(math.round(algo3_score, 0)), text_color=algo3_score >= scoreThreshold ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        // Weights
        table.cell(ensembleTable, 0, 9, "Weights:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(ensembleTable, 0, 9, 1, 9)

        table.cell(ensembleTable, 0, 10, "Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 10, str.tostring(normWeight1 * 100, "#") + "%", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        table.cell(ensembleTable, 0, 11, "MTF:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 11, str.tostring(normWeight2 * 100, "#") + "%", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        table.cell(ensembleTable, 0, 12, "Bayesian:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 12, str.tostring(normWeight3 * 100, "#") + "%", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        // Regime Info
        table.cell(ensembleTable, 0, 13, "Market Regime:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 13, regime3, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

// ============================= ALERTS =======================================

// Ensemble signal
alertcondition(ta.crossover(ensembleScore, scoreThreshold), "Ensemble Institutional Signal", "ENSEMBLE: Institutional " + institutionalType + " detected on {{ticker}} (Score: " + str.tostring(ensembleScore, "#") + ", Confidence: " + confidence + ")")

// High confidence signal (all 3 algorithms agree)
alertcondition(agreement == 3 and isInstitutional and not (isInstitutional[1] and agreement[1] == 3), "All Algorithms Agree", "VERY HIGH CONFIDENCE: All 3 algorithms detect institutional activity on {{ticker}} (Score: " + str.tostring(ensembleScore, "#") + ", Type: " + institutionalType + ")")

// Signal ended
alertcondition(ta.crossunder(ensembleScore, scoreThreshold), "Institutional Signal Ended", "Institutional activity ended on {{ticker}} (Score dropped below threshold)")
