//@version=5
indicator(title="Institutional Detection Ensemble", shorttitle="Inst Ensemble", overlay=false, precision=0, max_bars_back=500)

// ============================================================================
// ENSEMBLE INDICATOR: COMBINES ALL THREE INSTITUTIONAL ALGORITHMS
// ============================================================================
// Weighted combination of:
// 1. Volume Efficiency & Absorption (25%)
// 2. Multi-Timeframe Convergence (35%)
// 3. Bayesian Regime Classifier (40%)
// ============================================================================

// ============================= INPUTS =======================================

// Ensemble Weighting
weight_efficiency = input.float(0.25, "Weight: Volume Efficiency", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_mtf = input.float(0.35, "Weight: MTF Convergence", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_bayesian = input.float(0.40, "Weight: Bayesian", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")

// General Settings
scoreThreshold = input.int(70, "Ensemble Score Threshold", minval=50, maxval=90, group="Scoring")
enableAlgo1 = input.bool(true, "Enable Algorithm 1 (Efficiency)", group="Algorithm Selection")
enableAlgo2 = input.bool(true, "Enable Algorithm 2 (MTF)", group="Algorithm Selection")
enableAlgo3 = input.bool(true, "Enable Algorithm 3 (Bayesian)", group="Algorithm Selection")

// Visualization
showTable = input.bool(true, "Show Ensemble Table", group="Visualization")
showComponentScores = input.bool(true, "Show Individual Algorithm Scores", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")

// Backtesting
enableBacktest = input.bool(true, "Enable Backtesting", group="Debug & Testing")

// ============================================================================
// ALGORITHM 1: VOLUME EFFICIENCY & ABSORPTION
// ============================================================================

volumeLookback1 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 1: Efficiency")
volumeThreshold1 = input.float(1.5, "Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group="Algo 1: Efficiency")
efficiencyThreshold1 = input.float(1.3, "Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Algo 1: Efficiency")

// Calculations
avgVolume1 = ta.sma(volume, volumeLookback1)
relativeVolume1 = volume / avgVolume1
volumeScore1 = math.min(50, (relativeVolume1 - 1) * 25)

priceRange1 = high - low
avgPriceRange1 = ta.sma(priceRange1, volumeLookback1)
volumeEfficiency1 = volume / math.max(priceRange1, close * 0.0001)
avgVolumeEfficiency1 = ta.sma(volumeEfficiency1, volumeLookback1)
efficiencyRatio1 = volumeEfficiency1 / avgVolumeEfficiency1
efficiencyScore1 = efficiencyRatio1 > efficiencyThreshold1 ? math.min(30, (efficiencyRatio1 - 1) * 15) : 0

upperWick1 = high - math.max(open, close)
lowerWick1 = math.min(open, close) - low
totalWickSize1 = upperWick1 + lowerWick1
wickRatio1 = totalWickSize1 / math.max(priceRange1, close * 0.0001)
wickScore1 = wickRatio1 > 0.3 ? math.min(20, wickRatio1 * 40) : 0

closePosition1 = (close - low) / math.max(priceRange1, close * 0.0001)
controlScore1 = 0.0
if closePosition1 >= 0.4 and closePosition1 <= 0.6 and relativeVolume1 > 1.5
    controlScore1 := 10.0
else if closePosition1 > 0.7 and relativeVolume1 > 2.0
    controlScore1 := 5.0

algo1_score = enableAlgo1 ? math.min(100, volumeScore1 + efficiencyScore1 + wickScore1 + controlScore1) : 0.0
algo1_type = closePosition1 >= 0.4 and closePosition1 <= 0.6 ? "Accumulation" : "Distribution"

// ============================================================================
// ALGORITHM 2: MULTI-TIMEFRAME CONVERGENCE
// ============================================================================

// Auto-detect higher timeframes
getHigherTimeframe(baseTF) =>
    tfInMinutes = timeframe.in_seconds(baseTF) / 60
    string result = ""
    if tfInMinutes <= 1
        result := "5"
    else if tfInMinutes <= 5
        result := "15"
    else if tfInMinutes <= 15
        result := "60"
    else if tfInMinutes <= 60
        result := "240"
    else if tfInMinutes < 1440
        result := "D"
    else if baseTF == "D"
        result := "W"
    else
        result := "M"
    result

getSecondHigherTimeframe(baseTF) =>
    firstHTF = getHigherTimeframe(baseTF)
    getHigherTimeframe(firstHTF)

higherTF1 = getHigherTimeframe(timeframe.period)
higherTF2 = getSecondHigherTimeframe(timeframe.period)

volumeLookback2 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 2: MTF")
mtfVolumeThreshold = input.float(1.5, "MTF Volume Threshold", minval=1.0, maxval=5.0, step=0.1, group="Algo 2: MTF")

// Current timeframe
currentVolume2 = volume
currentAvgVolume2 = ta.sma(volume, volumeLookback2)
currentRelVol2 = currentVolume2 / currentAvgVolume2

// Higher timeframes
[htf1Volume, htf1AvgVolume] = request.security(syminfo.tickerid, higherTF1,
     [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)
htf1RelVol = htf1Volume / htf1AvgVolume

[htf2Volume, htf2AvgVolume] = request.security(syminfo.tickerid, higherTF2,
     [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)
htf2RelVol = htf2Volume / htf2AvgVolume

// Scoring
convergenceScore2 = 0.0
if currentRelVol2 > mtfVolumeThreshold and htf1RelVol > mtfVolumeThreshold and htf2RelVol > mtfVolumeThreshold
    convergenceScore2 := 40.0
else if (currentRelVol2 > mtfVolumeThreshold and htf1RelVol > mtfVolumeThreshold) or
        (htf1RelVol > mtfVolumeThreshold and htf2RelVol > mtfVolumeThreshold)
    convergenceScore2 := 25.0

volumePatternScore2 = htf2RelVol > htf1RelVol and htf1RelVol > currentRelVol2 and convergenceScore2 > 20 ? 20.0 : 0.0

currentRange2 = (high - low) / close
avgRange2 = ta.sma(currentRange2, volumeLookback2)
rangeRatio2 = currentRange2 / avgRange2

priceScore2 = 0.0
algo2_pattern = ""
if rangeRatio2 < 1.2 and convergenceScore2 > 20
    priceScore2 := 30.0
    algo2_pattern := "Accumulation"
else if rangeRatio2 > 1.2 and convergenceScore2 > 20
    priceScore2 := 20.0
    algo2_pattern := "Distribution"

htf1Close = request.security(syminfo.tickerid, higherTF1, close, lookahead=barmerge.lookahead_off)
htf1SMA = request.security(syminfo.tickerid, higherTF1, ta.sma(close, 50), lookahead=barmerge.lookahead_off)
trendScore2 = htf1Close > htf1SMA and convergenceScore2 > 20 ? 10.0 : 0.0

algo2_score = enableAlgo2 ? math.min(100, convergenceScore2 + volumePatternScore2 + priceScore2 + trendScore2) : 0.0

// ============================================================================
// ALGORITHM 3: BAYESIAN REGIME CLASSIFIER
// ============================================================================

regimeLength3 = input.int(100, "Regime Length", minval=50, maxval=200, group="Algo 3: Bayesian")
atrLength3 = input.int(14, "ATR Length", minval=7, maxval=50, group="Algo 3: Bayesian")

// Regime detection
currentATR3 = ta.atr(atrLength3)
avgATR3 = ta.sma(ta.atr(atrLength3), regimeLength3)
atrRatio3 = currentATR3 / avgATR3

isHighVol3 = atrRatio3 > 1.3
isLowVol3 = atrRatio3 < 0.7

[diPlus3, diMinus3, adxValue3] = ta.dmi(14, 14)
isTrending3 = adxValue3 > 25
isRanging3 = adxValue3 < 20

regime3 = ""
if isTrending3 and isHighVol3
    regime3 := "TrendHighVol"
else if isTrending3 and isLowVol3
    regime3 := "TrendLowVol"
else if isRanging3 and isHighVol3
    regime3 := "RangeHighVol"
else if isRanging3 and isLowVol3
    regime3 := "RangeLowVol"
else
    regime3 := "Neutral"

priorProbability3 = switch regime3
    "RangeLowVol" => 0.40
    "TrendLowVol" => 0.30
    "RangeHighVol" => 0.25
    "TrendHighVol" => 0.15
    => 0.20

// Feature detection
avgVolume3 = ta.sma(volume, 20)
highVolume3 = volume > (avgVolume3 * 2.0)

volumeEfficiency3 = volume / math.max(high - low, close * 0.0001)
avgVolumeEfficiency3 = ta.sma(volumeEfficiency3, 20)
highEfficiency3 = volumeEfficiency3 > (avgVolumeEfficiency3 * 1.5)

// Simplified likelihood (without intrabar for performance)
likelihoodGivenInst3 = 1.0
likelihoodGivenNotInst3 = 1.0

if regime3 == "RangeLowVol"
    if highVolume3
        likelihoodGivenInst3 *= 0.75
        likelihoodGivenNotInst3 *= 0.30
    if highEfficiency3
        likelihoodGivenInst3 *= 0.80
        likelihoodGivenNotInst3 *= 0.25
else if regime3 == "TrendHighVol"
    if highVolume3
        likelihoodGivenInst3 *= 0.85
        likelihoodGivenNotInst3 *= 0.60
    if highEfficiency3
        likelihoodGivenInst3 *= 0.60
        likelihoodGivenNotInst3 *= 0.40

numerator3 = likelihoodGivenInst3 * priorProbability3
denominator3 = (likelihoodGivenInst3 * priorProbability3) + (likelihoodGivenNotInst3 * (1 - priorProbability3))
posteriorProbability3 = denominator3 > 0 ? numerator3 / denominator3 : 0.0

signalCount3 = (highVolume3 ? 1 : 0) + (highEfficiency3 ? 1 : 0)
confidenceBoost3 = signalCount3 >= 2 ? 10.0 : 0.0

algo3_score = enableAlgo3 ? math.min(100, posteriorProbability3 * 100 + confidenceBoost3) : 0.0

// ============================================================================
// ENSEMBLE CALCULATION
// ============================================================================

// Normalize weights
totalWeight = weight_efficiency + weight_mtf + weight_bayesian
normWeight1 = totalWeight > 0 ? weight_efficiency / totalWeight : 0.33
normWeight2 = totalWeight > 0 ? weight_mtf / totalWeight : 0.33
normWeight3 = totalWeight > 0 ? weight_bayesian / totalWeight : 0.33

// Calculate weighted ensemble score
ensembleScore = (algo1_score * normWeight1) + (algo2_score * normWeight2) + (algo3_score * normWeight3)

// Agreement analysis
agreement = 0
if algo1_score >= scoreThreshold and enableAlgo1
    agreement += 1
if algo2_score >= scoreThreshold and enableAlgo2
    agreement += 1
if algo3_score >= scoreThreshold and enableAlgo3
    agreement += 1

// Confidence level
confidence = switch agreement
    3 => "High"
    2 => "Medium"
    1 => "Low"
    => "None"

// Classification
isInstitutional = ensembleScore >= scoreThreshold

institutionalType = ""
if isInstitutional
    if agreement >= 2
        if algo2_pattern == "Accumulation" or algo1_type == "Accumulation"
            institutionalType := "Accumulation"
        else if algo2_pattern == "Distribution"
            institutionalType := "Distribution"
        else
            institutionalType := "Mixed"
    else
        institutionalType := "Mixed"

// ============================= BACKTESTING ==================================

var int totalSignals = 0
var int wins5 = 0
var int wins20 = 0
var float totalReturn5 = 0.0
var float totalReturn20 = 0.0
var int highConfSignals = 0
var int medConfSignals = 0

if enableBacktest and isInstitutional
    totalSignals += 1

    if confidence == "High"
        highConfSignals += 1
    else if confidence == "Medium"
        medConfSignals += 1

    if bar_index < (last_bar_index - 20)
        forwardReturn5 = (close[5] - close) / close * 100
        forwardReturn20 = (close[20] - close) / close * 100

        totalReturn5 += forwardReturn5
        totalReturn20 += forwardReturn20

        if forwardReturn5 > 2.0
            wins5 += 1
        if forwardReturn20 > 5.0
            wins20 += 1

winRate5 = totalSignals > 0 ? (wins5 / totalSignals) * 100 : 0.0
winRate20 = totalSignals > 0 ? (wins20 / totalSignals) * 100 : 0.0
avgReturn5 = totalSignals > 0 ? totalReturn5 / totalSignals : 0.0
avgReturn20 = totalSignals > 0 ? totalReturn20 / totalSignals : 0.0

// ============================= VISUALIZATION ================================

// Color gradient
ensembleColor = ensembleScore >= 70 ? color.new(color.green, 0) :
                ensembleScore >= 50 ? color.new(color.yellow, 0) :
                ensembleScore >= 30 ? color.new(color.orange, 0) : color.new(color.red, 0)

// Main ensemble score
plot(ensembleScore, "Ensemble Score", color=ensembleColor, style=plot.style_area, linewidth=3)

// Individual algorithm scores
plot(showComponentScores ? algo1_score : na, "Algo 1: Efficiency", color=color.new(color.blue, 50), linewidth=2)
plot(showComponentScores ? algo2_score : na, "Algo 2: MTF", color=color.new(color.purple, 50), linewidth=2)
plot(showComponentScores ? algo3_score : na, "Algo 3: Bayesian", color=color.new(color.fuchsia, 50), linewidth=2)

// Reference lines
hline(scoreThreshold, "Threshold", color=color.new(color.white, 50), linestyle=hline.style_dashed, linewidth=2)
hline(50, "Midline", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Background tint based on confidence
bgcolor(isInstitutional and confidence == "High" ? color.new(color.green, 85) :
        isInstitutional and confidence == "Medium" ? color.new(color.yellow, 90) :
        isInstitutional ? color.new(color.orange, 95) : na)

// Chart markers
plotshape(showMarkers and isInstitutional and confidence == "High" ? ensembleScore : na,
     "High Confidence", shape.circle, location.bottom, color.new(color.green, 0), size=size.normal)
plotshape(showMarkers and isInstitutional and confidence == "Medium" ? ensembleScore : na,
     "Medium Confidence", shape.circle, location.bottom, color.new(color.yellow, 0), size=size.small)

// ============================= ENSEMBLE TABLE ===============================

if showTable
    var table ensembleTable = table.new(position.top_right, 2, 18, border_width=1)

    if barstate.islast
        // Header
        table.cell(ensembleTable, 0, 0, "ENSEMBLE INSTITUTIONAL DETECTION",
             text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
        table.merge_cells(ensembleTable, 0, 0, 1, 0)

        // Ensemble Score
        table.cell(ensembleTable, 0, 1, "Ensemble Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 1, str.tostring(math.round(ensembleScore, 0)),
             text_color=color.white, bgcolor=color.new(ensembleColor, 50), text_size=size.normal)

        table.cell(ensembleTable, 0, 2, "Confidence:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        confColor = confidence == "High" ? color.lime : confidence == "Medium" ? color.yellow : color.orange
        table.cell(ensembleTable, 1, 2, confidence, text_color=confColor, bgcolor=color.new(color.gray, 70), text_size=size.small)

        table.cell(ensembleTable, 0, 3, "Type:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 3, institutionalType,
             text_color=color.white, bgcolor=color.new(ensembleColor, 50), text_size=size.small)

        table.cell(ensembleTable, 0, 4, "Agreement:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(ensembleTable, 1, 4, str.tostring(agreement) + " / 3 algos",
             text_color=agreement >= 2 ? color.lime : color.orange,
             bgcolor=color.new(color.gray, 70), text_size=size.small)

        // Individual Algorithm Scores
        table.cell(ensembleTable, 0, 5, "Algorithm Scores:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(ensembleTable, 0, 5, 1, 5)

        algo1Check = algo1_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 6, "1. Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 6, algo1Check + " " + str.tostring(math.round(algo1_score, 0)),
             text_color=algo1_score >= scoreThreshold ? color.lime : color.gray,
             bgcolor=color.new(color.gray, 80), text_size=size.small)

        algo2Check = algo2_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 7, "2. MTF:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 7, algo2Check + " " + str.tostring(math.round(algo2_score, 0)),
             text_color=algo2_score >= scoreThreshold ? color.lime : color.gray,
             bgcolor=color.new(color.gray, 80), text_size=size.small)

        algo3Check = algo3_score >= scoreThreshold ? "✓" : "✗"
        table.cell(ensembleTable, 0, 8, "3. Bayesian:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 8, algo3Check + " " + str.tostring(math.round(algo3_score, 0)),
             text_color=algo3_score >= scoreThreshold ? color.lime : color.gray,
             bgcolor=color.new(color.gray, 80), text_size=size.small)

        // Weights
        table.cell(ensembleTable, 0, 9, "Weights:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(ensembleTable, 0, 9, 1, 9)

        table.cell(ensembleTable, 0, 10, "Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 10, str.tostring(normWeight1 * 100, "#") + "%",
             text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        table.cell(ensembleTable, 0, 11, "MTF:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 11, str.tostring(normWeight2 * 100, "#") + "%",
             text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        table.cell(ensembleTable, 0, 12, "Bayesian:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
        table.cell(ensembleTable, 1, 12, str.tostring(normWeight3 * 100, "#") + "%",
             text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

        // Regime Info
        table.cell(ensembleTable, 0, 13, "Market Regime:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(ensembleTable, 1, 13, regime3, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

        // Backtest Results
        if enableBacktest
            table.cell(ensembleTable, 0, 14, "Backtest Performance:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
            table.merge_cells(ensembleTable, 0, 14, 1, 14)

            table.cell(ensembleTable, 0, 15, "Total Signals:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(ensembleTable, 1, 15, str.tostring(totalSignals) + " (H:" + str.tostring(highConfSignals) + " M:" + str.tostring(medConfSignals) + ")",
                 text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

            table.cell(ensembleTable, 0, 16, "Win Rate (5/20):", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(ensembleTable, 1, 16, str.tostring(winRate5, "#") + "% / " + str.tostring(winRate20, "#") + "%",
                 text_color=winRate5 > 60 ? color.lime : winRate5 > 50 ? color.yellow : color.orange,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(ensembleTable, 0, 17, "Avg Return (5/20):", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(ensembleTable, 1, 17, str.tostring(avgReturn5, "#.#") + "% / " + str.tostring(avgReturn20, "#.#") + "%",
                 text_color=avgReturn5 > 0 ? color.lime : color.red,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)

// ============================= ALERTS =======================================

// Ensemble signal
alertcondition(ta.crossover(ensembleScore, scoreThreshold),
     "Ensemble Institutional Signal",
     "ENSEMBLE: Institutional " + institutionalType + " detected on {{ticker}} (Score: " +
     str.tostring(ensembleScore, "#") + ", Confidence: " + confidence + ")")

// High confidence signal (all 3 algorithms agree)
alertcondition(agreement == 3 and isInstitutional and not (isInstitutional[1] and agreement[1] == 3),
     "All Algorithms Agree",
     "VERY HIGH CONFIDENCE: All 3 algorithms detect institutional activity on {{ticker}} (Score: " +
     str.tostring(ensembleScore, "#") + ", Type: " + institutionalType + ")")

// Signal ended
alertcondition(ta.crossunder(ensembleScore, scoreThreshold),
     "Institutional Signal Ended",
     "Institutional activity ended on {{ticker}} (Score dropped below threshold)")
