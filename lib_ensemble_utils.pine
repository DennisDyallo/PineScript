//@version=5
// @description Common utilities for ensemble indicators to reduce code duplication
library("EnsembleUtils", overlay=false)

import redshad0ww/CoreMath/1 as math_lib

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type EnsembleResult
    float score
    bool isInstitutional
    int agreementCount
    string agreementLabel
    string confidence
    string institutionalType

export type PatternVotes
    int accumVotes
    int distrVotes
    int mixedVotes
    string consensusPattern

// ============================================================================
// ENSEMBLE CALCULATION
// ============================================================================

export calculateEnsemble(float algo1Score, float algo2Score, float algo3Score,
     float weight1, float weight2, float weight3, int threshold) =>

    var EnsembleResult result = EnsembleResult.new()

    // Normalize weights
    totalWeight = weight1 + weight2 + weight3
    normWeight1 = math_lib.safeDivide(weight1, totalWeight, 0.33)
    normWeight2 = math_lib.safeDivide(weight2, totalWeight, 0.33)
    normWeight3 = math_lib.safeDivide(weight3, totalWeight, 0.34)

    // Calculate weighted ensemble score
    ensembleScore = (algo1Score * normWeight1) + (algo2Score * normWeight2) + (algo3Score * normWeight3)

    // Agreement count
    agreementCount = 0
    if algo1Score >= 70
        agreementCount := agreementCount + 1
    if algo2Score >= 70
        agreementCount := agreementCount + 1
    if algo3Score >= 70
        agreementCount := agreementCount + 1

    // Agreement label
    agreementLabel = agreementCount == 3 ? "Strong (3/3)" :
         agreementCount == 2 ? "Moderate (2/3)" :
         agreementCount == 1 ? "Weak (1/3)" : "None (0/3)"

    // Confidence
    confidence = agreementCount == 3 ? "Very High" :
         agreementCount == 2 ? "High" :
         agreementCount == 1 ? "Medium" : "Low"

    // Classification
    isInstitutional = ensembleScore >= threshold

    result.score := ensembleScore
    result.isInstitutional := isInstitutional
    result.agreementCount := agreementCount
    result.agreementLabel := agreementLabel
    result.confidence := confidence
    result.institutionalType := "Mixed"  // Default, override with pattern consensus

    result

// ============================================================================
// PATTERN CONSENSUS (for V2/V3)
// ============================================================================

export calculatePatternConsensus(string algo1Pattern, string algo2Pattern, string algo3Pattern,
     bool enableAlgo1, bool enableAlgo2, bool enableAlgo3) =>

    var PatternVotes votes = PatternVotes.new()

    accumVotes = 0
    distrVotes = 0
    mixedVotes = 0

    if enableAlgo1
        if algo1Pattern == "ACCUM"
            accumVotes := accumVotes + 1
        else if algo1Pattern == "DISTR"
            distrVotes := distrVotes + 1
        else
            mixedVotes := mixedVotes + 1

    if enableAlgo2
        if algo2Pattern == "ACCUM"
            accumVotes := accumVotes + 1
        else if algo2Pattern == "DISTR"
            distrVotes := distrVotes + 1
        else
            mixedVotes := mixedVotes + 1

    if enableAlgo3
        if algo3Pattern == "ACCUM"
            accumVotes := accumVotes + 1
        else if algo3Pattern == "DISTR"
            distrVotes := distrVotes + 1
        else
            mixedVotes := mixedVotes + 1

    // Determine consensus
    consensusPattern = "Mixed"
    if accumVotes > distrVotes and accumVotes > mixedVotes
        consensusPattern := "Accumulation"
    else if distrVotes > accumVotes and distrVotes > mixedVotes
        consensusPattern := "Distribution"

    votes.accumVotes := accumVotes
    votes.distrVotes := distrVotes
    votes.mixedVotes := mixedVotes
    votes.consensusPattern := consensusPattern

    votes

// ============================================================================
// SIMPLE PATTERN TYPE (for V1 - based on dominant algorithm)
// ============================================================================

export getSimplePatternType(float algo1Score, float algo2Score, float algo3Score) =>
    string result = algo1Score >= algo2Score and algo1Score >= algo3Score ? "Volume Efficiency" :
         algo2Score >= algo1Score and algo2Score >= algo3Score ? "MTF Convergence" :
         "Bayesian Regime"
    result

// ============================================================================
// TABLE RENDERING HELPERS
// ============================================================================

export renderBasicTable(table t, float ensembleScore, bool isInstitutional, string agreementLabel,
     int agreementCount, float algo1Score, float algo2Score, float algo3Score,
     float normWeight1, float normWeight2, float normWeight3, string title) =>

    scoreColor = ensembleScore >= 70 ? color.green : ensembleScore >= 50 ? color.yellow : color.orange

    // Header
    table.cell(t, 0, 0, title, bgcolor=color.new(color.blue, 70),
         text_color=color.white, text_size=size.normal)
    table.merge_cells(t, 0, 0, 1, 0)

    // Ensemble score
    table.cell(t, 0, 1, "Ensemble Score:", text_halign=text.align_left, text_color=color.new(color.white, 20))
    table.cell(t, 1, 1, str.tostring(math.round(ensembleScore)), text_color=scoreColor)

    // Status
    table.cell(t, 0, 2, "Status:", text_halign=text.align_left, text_color=color.new(color.white, 20))
    table.cell(t, 1, 2, isInstitutional ? "✓ ACTIVE" : "○ Inactive",
         text_color=isInstitutional ? color.lime : color.new(color.white, 50))

    // Agreement
    table.cell(t, 0, 3, "Agreement:", text_halign=text.align_left, text_color=color.new(color.white, 20))
    table.cell(t, 1, 3, agreementLabel,
         text_color=agreementCount >= 2 ? color.lime : color.orange)

    // Separator
    table.cell(t, 0, 4, "Component Scores:", bgcolor=color.new(color.gray, 70),
         text_color=color.white, text_size=size.small)
    table.merge_cells(t, 0, 4, 1, 4)

    // Algorithm scores
    table.cell(t, 0, 5, "Efficiency:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, 5, str.tostring(math.round(algo1Score)) + " (" +
         str.tostring(math.round(normWeight1 * 100)) + "%)", text_size=size.small,
         text_color=algo1Score >= 70 ? color.lime : color.new(color.white, 50))

    table.cell(t, 0, 6, "MTF Convergence:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, 6, str.tostring(math.round(algo2Score)) + " (" +
         str.tostring(math.round(normWeight2 * 100)) + "%)", text_size=size.small,
         text_color=algo2Score >= 70 ? color.lime : color.new(color.white, 50))

    table.cell(t, 0, 7, "Bayesian:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, 7, str.tostring(math.round(algo3Score)) + " (" +
         str.tostring(math.round(normWeight3 * 100)) + "%)", text_size=size.small,
         text_color=algo3Score >= 70 ? color.lime : color.new(color.white, 50))

export addPatternConsensusToTable(table t, int startRow, PatternVotes votes) =>
    // Pattern Consensus
    table.cell(t, 0, startRow, "Pattern Type:", text_halign=text.align_left, text_color=color.new(color.white, 20))
    patternColor = votes.consensusPattern == "Accumulation" ? color.lime :
         votes.consensusPattern == "Distribution" ? color.red : color.orange
    table.cell(t, 1, startRow, votes.consensusPattern, text_color=patternColor)

    // Pattern voting breakdown
    table.cell(t, 0, startRow + 1, "Pattern Votes:", bgcolor=color.new(color.gray, 70),
         text_color=color.white, text_size=size.small)
    table.merge_cells(t, 0, startRow + 1, 1, startRow + 1)

    table.cell(t, 0, startRow + 2, "Accumulation:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, startRow + 2, str.tostring(votes.accumVotes) + "/3", text_size=size.small, text_color=color.new(color.white, 50))

    table.cell(t, 0, startRow + 3, "Distribution:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, startRow + 3, str.tostring(votes.distrVotes) + "/3", text_size=size.small, text_color=color.new(color.white, 50))

    table.cell(t, 0, startRow + 4, "Mixed:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, startRow + 4, str.tostring(votes.mixedVotes) + "/3", text_size=size.small, text_color=color.new(color.white, 50))

export addRegimeInfoToTable(table t, int startRow, string regimeName, float adxValue, bool isTrending) =>
    table.cell(t, 0, startRow, "Regime:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, startRow, regimeName, text_size=size.small, text_color=color.new(color.white, 50))

    table.cell(t, 0, startRow + 1, "ADX:", text_halign=text.align_left, text_size=size.small, text_color=color.new(color.white, 20))
    table.cell(t, 1, startRow + 1, str.tostring(math.round(adxValue, 1)),
         text_size=size.small, text_color=isTrending ? color.lime : color.new(color.white, 50))
