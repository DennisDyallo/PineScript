//@version=5
indicator("S/R Ensemble Detector V2", shorttitle="S/R Ensemble V2", overlay=true, max_lines_count=100, max_labels_count=30)

// ============================================================================
// ENSEMBLE S/R DETECTOR - REWRITTEN FROM SCRATCH
// ============================================================================
// Combines 4 algorithms with defensive array handling and simplified logic
// Research weights: VP(30%) + MTF(25%) + Statistical(20%) + OrderBook(15%)
// ============================================================================

// ============================= LIBRARY IMPORTS ==============================
import redshad0ww/CoreMath/1 as math_lib
import redshad0ww/RegimeDetection/2 as regime_lib
import redshad0ww/LevelUtils/1 as level_lib
import redshad0ww/MTFUtils/2 as mtf_lib
import redshad0ww/VolumeAnalysis/1 as vol_lib

// ============================= TYPE DEFINITIONS =============================

type SRLevel
    float price
    string levelType        // "Support" or "Resistance"
    float strength          // 0-100
    string source           // "VP", "STAT", "MTF", "OB"

type EnsembleLevel
    float price
    string levelType
    float ensembleStrength
    int agreementCount      // 1-4
    string sources
    string confidence
    color levelColor

// ============================= INPUTS =======================================

// Ensemble
maxLevels = input.int(15, "Max Levels", minval=5, maxval=30, group="Ensemble")
minAgreement = input.int(2, "Min Agreement", minval=1, maxval=4, group="Ensemble")
minStrength = input.int(60, "Min Strength", minval=40, maxval=90, group="Ensemble")
mergeTolerance = input.float(0.015, "Merge Tolerance %", minval=0.005, maxval=0.03, step=0.005, group="Ensemble")

// Algorithm toggles
enableVP = input.bool(true, "Volume Profile", group="Algorithms")
enableStat = input.bool(true, "Statistical", group="Algorithms")
enableMTF = input.bool(true, "MTF", group="Algorithms")
enableOB = input.bool(true, "Order Book", group="Algorithms")

// Algorithm 1: Volume Profile
vpLookback = input.int(200, "VP Lookback", minval=50, maxval=500, group="Volume Profile")
vpBins = input.int(40, "VP Bins", minval=20, maxval=60, group="Volume Profile")
vpMinStrength = input.int(60, "VP Min Strength", minval=40, maxval=85, group="Volume Profile")

// Algorithm 2: Statistical
statSwing = input.int(10, "Stat Swing", minval=5, maxval=20, group="Statistical")
statMinCluster = input.int(2, "Stat Min Cluster", minval=1, maxval=5, group="Statistical")
statDecay = input.float(0.9942, "Stat Decay", minval=0.85, maxval=0.998, step=0.0002, group="Statistical")

// Algorithm 3: MTF
mtfSwing = input.int(8, "MTF Swing", minval=5, maxval=20, group="MTF")

// Algorithm 4: Order Book
obLookback = input.int(200, "OB Lookback", minval=50, maxval=500, group="Order Book")
obMinWick = input.float(0.3, "OB Min Wick", minval=0.1, maxval=2.0, step=0.1, group="Order Book")
obMinReject = input.int(2, "OB Min Rejections", minval=1, maxval=5, group="Order Book")

// Display
showLabels = input.bool(true, "Show Labels", group="Display")
showSources = input.bool(true, "Show Sources", group="Display")
showTable = input.bool(true, "Show Table", group="Display")

// Regime
useRegime = input.bool(true, "Enable Regime", group="Regime")
atrLen = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime")
atrLook = input.int(50, "ATR Lookback", minval=20, maxval=100, group="Regime")

// ============================= SHARED CALCULATIONS ==========================

regimeData = regime_lib.detectRegime(atrLen, atrLook)
regimeMult = regimeData.multiplier
currentATR = ta.atr(atrLen)

// ============================= HELPER FUNCTIONS =============================

// Object-based clustering - NO parallel arrays = NO synchronization bugs!
// Takes array of SRLevel objects, returns clustered array of SRLevel objects
f_clusterLevels(array<SRLevel> levels, float tolerance) =>
    array<SRLevel> result = array.new<SRLevel>()  // No 'var' - create new array each call!

    levelCount = array.size(levels)

    if levelCount == 0
        result  // Return empty array immediately
    else
        // Create fresh visited array for THIS call (no 'var' = no persistent state bug)
        array<bool> visited = array.new_bool()

        // Initialize visited array
        for i = 0 to levelCount - 1
            array.push(visited, false)

        // Cluster levels
        for i = 0 to levelCount - 1
            if not array.get(visited, i)
                currentLevel = array.get(levels, i)

                // Start cluster
                clusterPrice = currentLevel.price
                clusterLevelType = currentLevel.levelType
                clusterStrength = currentLevel.strength
                clusterSource = currentLevel.source
                clusterCount = 1

                array.set(visited, i, true)

                // Find neighbors (same type only)
                for j = i + 1 to levelCount - 1
                    // Defensive bounds check (should be redundant but prevents edge cases)
                    if j >= 0 and j < levelCount
                        if not array.get(visited, j)
                            otherLevel = array.get(levels, j)
                            distance = math.abs(clusterPrice - otherLevel.price) / clusterPrice

                            if distance <= tolerance and clusterLevelType == otherLevel.levelType
                                // Weighted average by strength
                                totalStrength = clusterStrength * clusterCount + otherLevel.strength
                                clusterPrice := (clusterPrice * clusterCount + otherLevel.price) / (clusterCount + 1)
                                clusterCount += 1
                                clusterStrength := totalStrength / clusterCount

                                // Merge sources
                                if not str.contains(clusterSource, otherLevel.source)
                                    clusterSource += "+" + otherLevel.source

                                array.set(visited, j, true)

                // Add clustered level
                array.push(result, SRLevel.new(clusterPrice, clusterLevelType, clusterStrength, clusterSource))

        result

// ============================= ALGORITHM 1: VOLUME PROFILE ==================

var array<SRLevel> vpLevels = array.new<SRLevel>()

if enableVP and barstate.isconfirmed
    array.clear(vpLevels)

    highestPrice = ta.highest(high, vpLookback)
    lowestPrice = ta.lowest(low, vpLookback)
    priceRange = highestPrice - lowestPrice

    if priceRange > 0
        binSize = priceRange / vpBins

        array<float> volAtPrice = array.new_float()
        for i = 0 to vpBins - 1
            array.push(volAtPrice, 0.0)

        // Build volume profile
        for i = 0 to math.min(vpLookback - 1, bar_index)
            barClosePrice = close[i]
            barVol = volume[i]

            bin = math.floor((barClosePrice - lowestPrice) / binSize)
            bin := math.max(0, math.min(vpBins - 1, bin))

            array.set(volAtPrice, bin, array.get(volAtPrice, bin) + barVol)

        // Find POC
        pocIndex = 0
        pocVol = 0.0
        for i = 0 to vpBins - 1
            vol = array.get(volAtPrice, i)
            if vol > pocVol
                pocVol := vol
                pocIndex := i

        pocPrice = lowestPrice + (pocIndex * binSize) + (binSize / 2)
        pocLevel = SRLevel.new(pocPrice, close > pocPrice ? "Support" : "Resistance", 100.0, "VP")
        array.push(vpLevels, pocLevel)

        // Find HVN levels
        hvnThreshold = array.percentile_nearest_rank(volAtPrice, 85)

        for i = 1 to vpBins - 2
            vol = array.get(volAtPrice, i)
            leftVol = array.get(volAtPrice, i - 1)
            rightVol = array.get(volAtPrice, i + 1)

            if vol > leftVol and vol > rightVol and vol >= hvnThreshold
                if math.abs(i - pocIndex) > 2
                    hvnPrice = lowestPrice + (i * binSize) + (binSize / 2)
                    hvnStrength = 70.0 + (vol / pocVol) * 15

                    if hvnStrength >= vpMinStrength
                        hvnLevel = SRLevel.new(hvnPrice, close > hvnPrice ? "Support" : "Resistance", hvnStrength, "VP")
                        array.push(vpLevels, hvnLevel)

// ============================= ALGORITHM 2: STATISTICAL =====================

var array<SRLevel> statLevels = array.new<SRLevel>()

if enableStat and barstate.isconfirmed
    array.clear(statLevels)

    // Build array of SRLevel objects directly (no parallel arrays!)
    array<SRLevel> rawSwingLevels = array.new<SRLevel>()

    // Find pivots (only look back max 200 bars to avoid 10000 bar limit)
    if bar_index >= statSwing * 2
        maxLookback = math.min(200, bar_index - statSwing)
        for i = statSwing to maxLookback
            // Pivot high
            isPH = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0
                    if high[j] >= high[i]
                        isPH := false
                        break

            if isPH
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                // Create SRLevel object directly
                level = SRLevel.new(high[i], "Resistance", strength, "STAT")
                array.push(rawSwingLevels, level)

            // Pivot low
            isPL = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0
                    if low[j] <= low[i]
                        isPL := false
                        break

            if isPL
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                // Create SRLevel object directly
                level = SRLevel.new(low[i], "Support", strength, "STAT")
                array.push(rawSwingLevels, level)

    // Cluster using object-based function (no parallel arrays!)
    statLevels := f_clusterLevels(rawSwingLevels, 0.015)

    // Apply min/max strength constraints
    if array.size(statLevels) > 0
        for i = 0 to array.size(statLevels) - 1
            level = array.get(statLevels, i)
            level.strength := math.max(40, math.min(100, level.strength))

// ============================= ALGORITHM 3: MTF =========================== ==

var array<SRLevel> mtfLevels = array.new<SRLevel>()

if enableMTF and barstate.isconfirmed
    array.clear(mtfLevels)

    // Build array of SRLevel objects directly
    array<SRLevel> rawMtfLevels = array.new<SRLevel>()

    // Current TF pivots (only look back max 100 bars to avoid 10000 bar limit)
    if bar_index >= mtfSwing * 2
        maxLookback = math.min(100, bar_index - mtfSwing)
        for i = mtfSwing to maxLookback
            // Pivot high
            isPH = true
            for j = i - mtfSwing to i + mtfSwing
                if j != i and j >= 0
                    if high[j] >= high[i]
                        isPH := false
                        break

            if isPH
                strength = 50.0 * (useRegime ? regimeMult : 1.0)
                level = SRLevel.new(high[i], "Resistance", strength, "MTF")
                array.push(rawMtfLevels, level)

            // Pivot low
            isPL = true
            for j = i - mtfSwing to i + mtfSwing
                if j != i and j >= 0
                    if low[j] <= low[i]
                        isPL := false
                        break

            if isPL
                strength = 50.0 * (useRegime ? regimeMult : 1.0)
                level = SRLevel.new(low[i], "Support", strength, "MTF")
                array.push(rawMtfLevels, level)

    // Cluster using object-based function
    mtfLevels := f_clusterLevels(rawMtfLevels, 0.015)

    // Apply min/max strength constraints
    if array.size(mtfLevels) > 0
        for i = 0 to array.size(mtfLevels) - 1
            level = array.get(mtfLevels, i)
            level.strength := math.max(40, math.min(100, level.strength))

// ============================= ALGORITHM 4: ORDER BOOK ======================

var array<SRLevel> obLevels = array.new<SRLevel>()

if enableOB and barstate.isconfirmed
    array.clear(obLevels)

    // Build array of SRLevel objects directly
    array<SRLevel> rawRejectionLevels = array.new<SRLevel>()

    avgVol = ta.sma(volume, 20)

    for i = 0 to math.min(obLookback, bar_index)
        barHigh = high[i]
        barLow = low[i]
        barOpen = open[i]
        barClose = close[i]
        barVol = volume[i]

        bodyTop = math.max(barOpen, barClose)
        bodyBottom = math.min(barOpen, barClose)
        bodySize = bodyTop - bodyBottom

        upperWick = barHigh - bodyTop
        lowerWick = bodyBottom - barLow

        if bodySize > 0 and barVol > avgVol * 0.8
            // Upper wick rejection
            if upperWick / bodySize > obMinWick
                strength = 40.0 + (upperWick / bodySize) * 20
                level = SRLevel.new(barHigh, "Resistance", strength, "OB")
                array.push(rawRejectionLevels, level)

            // Lower wick rejection
            if lowerWick / bodySize > obMinWick
                strength = 40.0 + (lowerWick / bodySize) * 20
                level = SRLevel.new(barLow, "Support", strength, "OB")
                array.push(rawRejectionLevels, level)

    // Cluster using object-based function
    epsilon = currentATR > 0 ? math.min(0.03, (currentATR / close) * 1.5) : 0.015
    obLevels := f_clusterLevels(rawRejectionLevels, epsilon)

    // Apply min/max strength constraints
    if array.size(obLevels) > 0
        for i = 0 to array.size(obLevels) - 1
            level = array.get(obLevels, i)
            level.strength := math.max(40, math.min(100, level.strength))

// ============================= ENSEMBLE MERGING =============================

var array<EnsembleLevel> ensembleLevels = array.new<EnsembleLevel>()

if barstate.isconfirmed
    array.clear(ensembleLevels)

    // Collect all levels
    array<SRLevel> allLevels = array.new<SRLevel>()

    // Safe collection with size checks
    if enableVP
        vpSize = array.size(vpLevels)
        if vpSize > 0
            for i = 0 to vpSize - 1
                array.push(allLevels, array.get(vpLevels, i))

    if enableStat
        statSize = array.size(statLevels)
        if statSize > 0
            for i = 0 to statSize - 1
                array.push(allLevels, array.get(statLevels, i))

    if enableMTF
        mtfSize = array.size(mtfLevels)
        if mtfSize > 0
            for i = 0 to mtfSize - 1
                array.push(allLevels, array.get(mtfLevels, i))

    if enableOB
        obSize = array.size(obLevels)
        if obSize > 0
            for i = 0 to obSize - 1
                array.push(allLevels, array.get(obLevels, i))

    // Merge nearby levels
    totalLevels = array.size(allLevels)

    if totalLevels > 0
        // Fresh merge tracking for THIS bar (no 'var' = no state persistence bug)
        array<bool> merged = array.new_bool()
        for i = 0 to totalLevels - 1
            array.push(merged, false)

        for i = 0 to totalLevels - 1
            if not array.get(merged, i)
                currentLevel = array.get(allLevels, i)

                // Start ensemble cluster
                clusterPrice = currentLevel.price
                clusterType = currentLevel.levelType
                clusterCount = 1

                vpScore = currentLevel.source == "VP" ? currentLevel.strength : 0.0
                statScore = currentLevel.source == "STAT" ? currentLevel.strength : 0.0
                mtfScore = currentLevel.source == "MTF" ? currentLevel.strength : 0.0
                obScore = currentLevel.source == "OB" ? currentLevel.strength : 0.0

                sources = currentLevel.source

                array.set(merged, i, true)

                // Find nearby levels
                for j = i + 1 to totalLevels - 1
                    // Defensive bounds check (prevents PineScript loop edge case)
                    if j >= 0 and j < totalLevels
                        if not array.get(merged, j)
                            otherLevel = array.get(allLevels, j)
                            distance = level_lib.calculateDistance(currentLevel.price, otherLevel.price)

                            if distance <= mergeTolerance and currentLevel.levelType == otherLevel.levelType
                                // Merge
                                clusterPrice := (clusterPrice * clusterCount + otherLevel.price) / (clusterCount + 1)
                                clusterCount += 1

                                if otherLevel.source == "VP" and vpScore == 0.0
                                    vpScore := otherLevel.strength
                                    sources := sources + "+VP"
                                else if otherLevel.source == "STAT" and statScore == 0.0
                                    statScore := otherLevel.strength
                                    sources := sources + "+STAT"
                                else if otherLevel.source == "MTF" and mtfScore == 0.0
                                    mtfScore := otherLevel.strength
                                    sources := sources + "+MTF"
                                else if otherLevel.source == "OB" and obScore == 0.0
                                    obScore := otherLevel.strength
                                    sources := sources + "+OB"

                                array.set(merged, j, true)

                // Calculate ensemble score
                agreement = (vpScore > 0 ? 1 : 0) + (statScore > 0 ? 1 : 0) + (mtfScore > 0 ? 1 : 0) + (obScore > 0 ? 1 : 0)

                baseScore = (vpScore * 0.30) + (statScore * 0.20) + (mtfScore * 0.25) + (obScore * 0.15)

                agreementBonus = agreement == 4 ? 1.30 : agreement == 3 ? 1.20 : agreement == 2 ? 1.10 : 1.0

                ensembleStrength = math.min(100, baseScore * agreementBonus)

                confidence = agreement == 4 ? "VERY HIGH" : agreement == 3 ? "HIGH" : agreement == 2 ? "MODERATE" : "LOW"

                levelColor = clusterType == "Support" ?
                     (ensembleStrength >= 80 ? color.new(color.green, 0) : color.new(color.green, 30)) :
                     (ensembleStrength >= 80 ? color.new(color.red, 0) : color.new(color.red, 30))

                // Filter and add
                if agreement >= minAgreement and ensembleStrength >= minStrength
                    ensembleLevel = EnsembleLevel.new(clusterPrice, clusterType, ensembleStrength, agreement, sources, confidence, levelColor)
                    array.push(ensembleLevels, ensembleLevel)

    // Sort by strength
    ensembleSize = array.size(ensembleLevels)
    if ensembleSize > 1
        for i = 0 to ensembleSize - 2
            for j = i + 1 to ensembleSize - 1
                // Defensive bounds check
                if i >= 0 and i < ensembleSize and j >= 0 and j < ensembleSize
                    if array.get(ensembleLevels, j).ensembleStrength > array.get(ensembleLevels, i).ensembleStrength
                        temp = array.get(ensembleLevels, i)
                        array.set(ensembleLevels, i, array.get(ensembleLevels, j))
                        array.set(ensembleLevels, j, temp)

// ============================= VISUALIZATION ================================

// Draw levels (only on confirmed bars to avoid redrawing every tick)
if barstate.isconfirmed and array.size(ensembleLevels) > 0
    levelsToShow = math.min(maxLevels, array.size(ensembleLevels))

    for i = 0 to levelsToShow - 1
        level = array.get(ensembleLevels, i)

        lineWidth = level.agreementCount == 4 ? 3 : level.agreementCount == 3 ? 2 : 1

        line.new(bar_index - 50, level.price, bar_index + 50, level.price,
             color=level.levelColor, width=lineWidth, extend=extend.right)

        if showLabels
            labelText = str.tostring(math.round(level.ensembleStrength))
            if showSources
                labelText += " (" + level.sources + ")"

            labelStyle = level.levelType == "Support" ? label.style_label_up : label.style_label_down

            label.new(bar_index + 10, level.price, labelText,
                 style=labelStyle, color=level.levelColor, textcolor=color.white,
                 size=level.agreementCount >= 3 ? size.normal : size.small)

// Info table (update when data changes or on last bar)
if showTable
    var table info = table.new(position.top_right, 2, 7, border_width=1)

    if barstate.islast or barstate.isconfirmed
        table.cell(info, 0, 0, "S/R Ensemble V2", text_color=color.white,
             bgcolor=color.new(color.blue, 30), text_size=size.normal)
        table.merge_cells(info, 0, 0, 1, 0)

        // Debug: Show algorithm level counts
        table.cell(info, 0, 1, "Algo Counts:", text_color=color.white,
             bgcolor=color.new(color.gray, 60), text_size=size.tiny)
        debugText = "VP:" + str.tostring(array.size(vpLevels)) + " ST:" + str.tostring(array.size(statLevels)) +
                   " MTF:" + str.tostring(array.size(mtfLevels)) + " OB:" + str.tostring(array.size(obLevels)) +
                   " Bar:" + str.tostring(bar_index)
        table.cell(info, 1, 1, debugText,
             text_color=color.yellow, bgcolor=color.new(color.gray, 60), text_size=size.tiny)

        table.cell(info, 0, 2, "Total Levels:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 2, str.tostring(array.size(ensembleLevels)),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        table.cell(info, 0, 3, "Showing:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 3, str.tostring(math.min(maxLevels, array.size(ensembleLevels))),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        if array.size(ensembleLevels) > 0
            topLevel = array.get(ensembleLevels, 0)

            table.cell(info, 0, 4, "Strongest:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 4, str.tostring(topLevel.price, format.mintick),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 5, "Strength:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 5, str.tostring(math.round(topLevel.ensembleStrength)),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 6, "Agreement:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 6, str.tostring(topLevel.agreementCount) + "/4",
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)
        else
            table.cell(info, 0, 4, "Status:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 4, "No levels found",
                 text_color=color.orange, bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.merge_cells(info, 0, 4, 1, 4)

// ============================= ALERTS =======================================

highConfNearby = false
ensembleSize = array.size(ensembleLevels)
if ensembleSize > 0
    maxCheck = math.min(3, ensembleSize - 1)
    if maxCheck >= 0
        for i = 0 to maxCheck
            level = array.get(ensembleLevels, i)
            if level.agreementCount >= 3
                distance = level_lib.calculateDistance(level.price, close)
                if distance < 0.01
                    highConfNearby := true
                    break

if highConfNearby and not highConfNearby[1]
    alert("Price near high-confidence S/R on " + syminfo.ticker, alert.freq_once_per_bar_close)

perfectAgree = false
if array.size(ensembleLevels) > 0
    topLevel = array.get(ensembleLevels, 0)
    if topLevel.agreementCount == 4
        distance = level_lib.calculateDistance(topLevel.price, close)
        if distance < 0.015
            perfectAgree := true

if perfectAgree and not perfectAgree[1]
    topLevel = array.get(ensembleLevels, 0)
    alert("PERFECT AGREEMENT: " + topLevel.levelType + " at " + str.tostring(topLevel.price, format.mintick) +
          " on " + syminfo.ticker, alert.freq_once_per_bar_close)
