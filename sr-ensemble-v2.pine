//@version=5
indicator("S/R Ensemble Detector V2", shorttitle="S/R Ensemble V2", overlay=true, max_lines_count=100, max_labels_count=30)

// ============================================================================
// ENSEMBLE S/R DETECTOR - REWRITTEN FROM SCRATCH
// ============================================================================
// Combines 4 algorithms with defensive array handling and simplified logic
// Research weights: VP(30%) + MTF(25%) + Statistical(20%) + OrderBook(15%)
// ============================================================================

// ============================= LIBRARY IMPORTS ==============================
import redshad0ww/CoreMath/1 as math_lib
import redshad0ww/RegimeDetection/2 as regime_lib
import redshad0ww/LevelUtils/1 as level_lib
import redshad0ww/MTFUtils/2 as mtf_lib
import redshad0ww/VolumeAnalysis/1 as vol_lib

// ============================= TYPE DEFINITIONS =============================

type SRLevel
    float price
    string levelType        // "Support" or "Resistance"
    float strength          // 0-100
    string source           // "VP", "STAT", "MTF", "OB"

type EnsembleLevel
    float price
    string levelType
    float ensembleStrength
    int agreementCount      // 1-4
    string sources
    string confidence
    color levelColor

// ============================= INPUTS =======================================

// Ensemble
maxLevels = input.int(15, "Max Levels", minval=5, maxval=30, group="Ensemble")
minAgreement = input.int(2, "Min Agreement", minval=1, maxval=4, group="Ensemble")
minStrength = input.int(60, "Min Strength", minval=40, maxval=90, group="Ensemble")
mergeTolerance = input.float(0.015, "Merge Tolerance %", minval=0.005, maxval=0.03, step=0.005, group="Ensemble")

// Algorithm toggles
enableVP = input.bool(true, "Volume Profile", group="Algorithms")
enableStat = input.bool(true, "Statistical", group="Algorithms")
enableMTF = input.bool(true, "MTF", group="Algorithms")
enableOB = input.bool(true, "Order Book", group="Algorithms")

// Algorithm 1: Volume Profile
vpLookback = input.int(200, "VP Lookback", minval=50, maxval=500, group="Volume Profile")
vpBins = input.int(40, "VP Bins", minval=20, maxval=60, group="Volume Profile")
vpMinStrength = input.int(60, "VP Min Strength", minval=40, maxval=85, group="Volume Profile")

// Algorithm 2: Statistical
statSwing = input.int(10, "Stat Swing", minval=5, maxval=20, group="Statistical")
statMinCluster = input.int(2, "Stat Min Cluster", minval=1, maxval=5, group="Statistical")
statDecay = input.float(0.9942, "Stat Decay", minval=0.85, maxval=0.998, step=0.0002, group="Statistical")

// Algorithm 3: MTF
mtfSwing = input.int(8, "MTF Swing", minval=5, maxval=20, group="MTF")

// Algorithm 4: Order Book
obLookback = input.int(200, "OB Lookback", minval=50, maxval=500, group="Order Book")
obMinWick = input.float(0.3, "OB Min Wick", minval=0.1, maxval=2.0, step=0.1, group="Order Book")
obMinReject = input.int(2, "OB Min Rejections", minval=1, maxval=5, group="Order Book")

// Display
showLabels = input.bool(true, "Show Labels", group="Display")
showSources = input.bool(true, "Show Sources", group="Display")
showTable = input.bool(true, "Show Table", group="Display")

// Regime
useRegime = input.bool(true, "Enable Regime", group="Regime")
atrLen = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime")
atrLook = input.int(50, "ATR Lookback", minval=20, maxval=100, group="Regime")

// ============================= SHARED CALCULATIONS ==========================

regimeData = regime_lib.detectRegime(atrLen, atrLook)
regimeMult = regimeData.multiplier
currentATR = ta.atr(atrLen)

// ============================= HELPER FUNCTIONS =============================

// Safe array builder - ensures all parallel arrays stay in sync
f_addLevel(array<float> prices, array<string> types, array<float> strengths, float price, string type, float strength) =>
    array.push(prices, price)
    array.push(types, type)
    array.push(strengths, strength)

// Safe clustering - returns clustered levels with guaranteed array consistency
f_cluster(array<float> prices, array<string> types, array<float> strengths, float tolerance) =>
    var array<float> clusteredPrices = array.new_float()
    var array<string> clusteredTypes = array.new_string()
    var array<float> clusteredStrengths = array.new_float()

    array.clear(clusteredPrices)
    array.clear(clusteredTypes)
    array.clear(clusteredStrengths)

    arraySize = array.size(prices)

    if arraySize > 0
        // Ensure all arrays have same size (defensive check)
        minSize = math.min(math.min(arraySize, array.size(types)), array.size(strengths))

        var array<bool> visited = array.new_bool()
        array.clear(visited)
        for i = 0 to minSize - 1
            array.push(visited, false)

        for i = 0 to minSize - 1
            if not array.get(visited, i)
                // Start cluster
                clusterPrice = array.get(prices, i)
                clusterType = array.get(types, i)
                clusterStrength = array.get(strengths, i)
                clusterCount = 1

                array.set(visited, i, true)

                // Find neighbors within tolerance
                for j = i + 1 to minSize - 1
                    if not array.get(visited, j)
                        otherPrice = array.get(prices, j)
                        otherType = array.get(types, j)

                        distance = math.abs(clusterPrice - otherPrice) / clusterPrice

                        if distance <= tolerance and clusterType == otherType
                            // Merge into cluster
                            clusterPrice := (clusterPrice * clusterCount + otherPrice) / (clusterCount + 1)
                            clusterStrength := math.max(clusterStrength, array.get(strengths, j))
                            clusterCount += 1
                            array.set(visited, j, true)

                // Add clustered level
                array.push(clusteredPrices, clusterPrice)
                array.push(clusteredTypes, clusterType)
                array.push(clusteredStrengths, clusterStrength)

    [clusteredPrices, clusteredTypes, clusteredStrengths]

// ============================= ALGORITHM 1: VOLUME PROFILE ==================

var array<SRLevel> vpLevels = array.new<SRLevel>()

if enableVP and (barstate.isconfirmed or barstate.islast)
    array.clear(vpLevels)

    highestPrice = ta.highest(high, vpLookback)
    lowestPrice = ta.lowest(low, vpLookback)
    priceRange = highestPrice - lowestPrice

    if priceRange > 0
        binSize = priceRange / vpBins

        var array<float> volAtPrice = array.new_float()
        array.clear(volAtPrice)
        for i = 0 to vpBins - 1
            array.push(volAtPrice, 0.0)

        // Build volume profile
        for i = 0 to math.min(vpLookback - 1, bar_index)
            barClosePrice = close[i]
            barVol = volume[i]

            bin = math.floor((barClosePrice - lowestPrice) / binSize)
            bin := math.max(0, math.min(vpBins - 1, bin))

            array.set(volAtPrice, bin, array.get(volAtPrice, bin) + barVol)

        // Find POC
        pocIndex = 0
        pocVol = 0.0
        for i = 0 to vpBins - 1
            vol = array.get(volAtPrice, i)
            if vol > pocVol
                pocVol := vol
                pocIndex := i

        pocPrice = lowestPrice + (pocIndex * binSize) + (binSize / 2)
        pocLevel = SRLevel.new(pocPrice, close > pocPrice ? "Support" : "Resistance", 100.0, "VP")
        array.push(vpLevels, pocLevel)

        // Find HVN levels
        hvnThreshold = array.percentile_nearest_rank(volAtPrice, 85)

        for i = 1 to vpBins - 2
            vol = array.get(volAtPrice, i)
            leftVol = array.get(volAtPrice, i - 1)
            rightVol = array.get(volAtPrice, i + 1)

            if vol > leftVol and vol > rightVol and vol >= hvnThreshold
                if math.abs(i - pocIndex) > 2
                    hvnPrice = lowestPrice + (i * binSize) + (binSize / 2)
                    hvnStrength = 70.0 + (vol / pocVol) * 15

                    if hvnStrength >= vpMinStrength
                        hvnLevel = SRLevel.new(hvnPrice, close > hvnPrice ? "Support" : "Resistance", hvnStrength, "VP")
                        array.push(vpLevels, hvnLevel)

// ============================= ALGORITHM 2: STATISTICAL =====================

var array<SRLevel> statLevels = array.new<SRLevel>()

if enableStat and (barstate.isconfirmed or barstate.islast)
    array.clear(statLevels)

    var array<float> swingPrices = array.new_float()
    var array<string> swingTypes = array.new_string()
    var array<float> swingStrengths = array.new_float()

    array.clear(swingPrices)
    array.clear(swingTypes)
    array.clear(swingStrengths)

    // Find pivots
    if bar_index >= statSwing * 2
        for i = statSwing to math.min(200, bar_index - statSwing)
            // Pivot high
            isPH = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0 and j <= bar_index
                    if high[bar_index - j] >= high[bar_index - i]
                        isPH := false
                        break

            if isPH
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                f_addLevel(swingPrices, swingTypes, swingStrengths, high[bar_index - i], "Resistance", strength)

            // Pivot low
            isPL = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0 and j <= bar_index
                    if low[bar_index - j] <= low[bar_index - i]
                        isPL := false
                        break

            if isPL
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                f_addLevel(swingPrices, swingTypes, swingStrengths, low[bar_index - i], "Support", strength)

    // Cluster swings
    [clusteredPrices, clusteredTypes, clusteredStrengths] = f_cluster(swingPrices, swingTypes, swingStrengths, 0.015)

    // Convert to levels
    clusterSize = array.size(clusteredPrices)
    for i = 0 to clusterSize - 1
        price = array.get(clusteredPrices, i)
        type = array.get(clusteredTypes, i)
        strength = math.max(40, math.min(100, array.get(clusteredStrengths, i)))

        level = SRLevel.new(price, type, strength, "STAT")
        array.push(statLevels, level)

// ============================= ALGORITHM 3: MTF =========================== ==

var array<SRLevel> mtfLevels = array.new<SRLevel>()

if enableMTF and (barstate.isconfirmed or barstate.islast)
    array.clear(mtfLevels)

    var array<float> mtfPrices = array.new_float()
    var array<string> mtfTypes = array.new_string()
    var array<float> mtfStrengths = array.new_float()

    array.clear(mtfPrices)
    array.clear(mtfTypes)
    array.clear(mtfStrengths)

    // Current TF pivots
    if bar_index >= mtfSwing * 2
        for i = mtfSwing to math.min(100, bar_index - mtfSwing)
            // Pivot high
            isPH = true
            for j = i - mtfSwing to i + mtfSwing
                if j != i and j >= 0 and j <= bar_index
                    if high[bar_index - j] >= high[bar_index - i]
                        isPH := false
                        break

            if isPH
                strength = 50.0 * (useRegime ? regimeMult : 1.0)
                f_addLevel(mtfPrices, mtfTypes, mtfStrengths, high[bar_index - i], "Resistance", strength)

            // Pivot low
            isPL = true
            for j = i - mtfSwing to i + mtfSwing
                if j != i and j >= 0 and j <= bar_index
                    if low[bar_index - j] <= low[bar_index - i]
                        isPL := false
                        break

            if isPL
                strength = 50.0 * (useRegime ? regimeMult : 1.0)
                f_addLevel(mtfPrices, mtfTypes, mtfStrengths, low[bar_index - i], "Support", strength)

    // Cluster
    [clusteredPrices, clusteredTypes, clusteredStrengths] = f_cluster(mtfPrices, mtfTypes, mtfStrengths, 0.015)

    // Convert to levels
    clusterSize = array.size(clusteredPrices)
    for i = 0 to clusterSize - 1
        price = array.get(clusteredPrices, i)
        type = array.get(clusteredTypes, i)
        strength = math.max(40, math.min(100, array.get(clusteredStrengths, i)))

        level = SRLevel.new(price, type, strength, "MTF")
        array.push(mtfLevels, level)

// ============================= ALGORITHM 4: ORDER BOOK ======================

var array<SRLevel> obLevels = array.new<SRLevel>()

if enableOB and (barstate.isconfirmed or barstate.islast)
    array.clear(obLevels)

    var array<float> rejPrices = array.new_float()
    var array<string> rejTypes = array.new_string()
    var array<float> rejStrengths = array.new_float()

    array.clear(rejPrices)
    array.clear(rejTypes)
    array.clear(rejStrengths)

    avgVol = ta.sma(volume, 20)

    for i = 0 to math.min(obLookback, bar_index)
        barHigh = high[i]
        barLow = low[i]
        barOpen = open[i]
        barClose = close[i]
        barVol = volume[i]

        bodyTop = math.max(barOpen, barClose)
        bodyBottom = math.min(barOpen, barClose)
        bodySize = bodyTop - bodyBottom

        upperWick = barHigh - bodyTop
        lowerWick = bodyBottom - barLow

        if bodySize > 0 and barVol > avgVol * 0.8
            // Upper wick rejection
            if upperWick / bodySize > obMinWick
                strength = 40.0 + (upperWick / bodySize) * 20
                f_addLevel(rejPrices, rejTypes, rejStrengths, barHigh, "Resistance", strength)

            // Lower wick rejection
            if lowerWick / bodySize > obMinWick
                strength = 40.0 + (lowerWick / bodySize) * 20
                f_addLevel(rejPrices, rejTypes, rejStrengths, barLow, "Support", strength)

    // Cluster
    epsilon = currentATR > 0 ? math.min(0.03, (currentATR / close) * 1.5) : 0.015
    [clusteredPrices, clusteredTypes, clusteredStrengths] = f_cluster(rejPrices, rejTypes, rejStrengths, epsilon)

    // Convert to levels
    clusterSize = array.size(clusteredPrices)
    for i = 0 to clusterSize - 1
        price = array.get(clusteredPrices, i)
        type = array.get(clusteredTypes, i)
        strength = math.max(40, math.min(100, array.get(clusteredStrengths, i)))

        level = SRLevel.new(price, type, strength, "OB")
        array.push(obLevels, level)

// ============================= ENSEMBLE MERGING =============================

var array<EnsembleLevel> ensembleLevels = array.new<EnsembleLevel>()

if barstate.isconfirmed or barstate.islast
    array.clear(ensembleLevels)

    // Collect all levels
    var array<SRLevel> allLevels = array.new<SRLevel>()
    array.clear(allLevels)

    // Safe collection with size checks
    if enableVP
        vpSize = array.size(vpLevels)
        for i = 0 to vpSize - 1
            array.push(allLevels, array.get(vpLevels, i))

    if enableStat
        statSize = array.size(statLevels)
        for i = 0 to statSize - 1
            array.push(allLevels, array.get(statLevels, i))

    if enableMTF
        mtfSize = array.size(mtfLevels)
        for i = 0 to mtfSize - 1
            array.push(allLevels, array.get(mtfLevels, i))

    if enableOB
        obSize = array.size(obLevels)
        for i = 0 to obSize - 1
            array.push(allLevels, array.get(obLevels, i))

    // Merge nearby levels
    totalLevels = array.size(allLevels)

    if totalLevels > 0
        var array<bool> merged = array.new_bool()
        array.clear(merged)
        for i = 0 to totalLevels - 1
            array.push(merged, false)

        for i = 0 to totalLevels - 1
            if not array.get(merged, i)
                currentLevel = array.get(allLevels, i)

                // Start ensemble cluster
                clusterPrice = currentLevel.price
                clusterType = currentLevel.levelType
                clusterCount = 1

                vpScore = currentLevel.source == "VP" ? currentLevel.strength : 0.0
                statScore = currentLevel.source == "STAT" ? currentLevel.strength : 0.0
                mtfScore = currentLevel.source == "MTF" ? currentLevel.strength : 0.0
                obScore = currentLevel.source == "OB" ? currentLevel.strength : 0.0

                sources = currentLevel.source

                array.set(merged, i, true)

                // Find nearby levels
                for j = i + 1 to totalLevels - 1
                    if not array.get(merged, j)
                        otherLevel = array.get(allLevels, j)
                        distance = level_lib.calculateDistance(currentLevel.price, otherLevel.price)

                        if distance <= mergeTolerance and currentLevel.levelType == otherLevel.levelType
                            // Merge
                            clusterPrice := (clusterPrice * clusterCount + otherLevel.price) / (clusterCount + 1)
                            clusterCount += 1

                            if otherLevel.source == "VP" and vpScore == 0.0
                                vpScore := otherLevel.strength
                                sources := sources + "+VP"
                            else if otherLevel.source == "STAT" and statScore == 0.0
                                statScore := otherLevel.strength
                                sources := sources + "+STAT"
                            else if otherLevel.source == "MTF" and mtfScore == 0.0
                                mtfScore := otherLevel.strength
                                sources := sources + "+MTF"
                            else if otherLevel.source == "OB" and obScore == 0.0
                                obScore := otherLevel.strength
                                sources := sources + "+OB"

                            array.set(merged, j, true)

                // Calculate ensemble score
                agreement = (vpScore > 0 ? 1 : 0) + (statScore > 0 ? 1 : 0) + (mtfScore > 0 ? 1 : 0) + (obScore > 0 ? 1 : 0)

                baseScore = (vpScore * 0.30) + (statScore * 0.20) + (mtfScore * 0.25) + (obScore * 0.15)

                agreementBonus = agreement == 4 ? 1.30 : agreement == 3 ? 1.20 : agreement == 2 ? 1.10 : 1.0

                ensembleStrength = math.min(100, baseScore * agreementBonus)

                confidence = agreement == 4 ? "VERY HIGH" : agreement == 3 ? "HIGH" : agreement == 2 ? "MODERATE" : "LOW"

                levelColor = clusterType == "Support" ?
                     (ensembleStrength >= 80 ? color.new(color.green, 0) : color.new(color.green, 30)) :
                     (ensembleStrength >= 80 ? color.new(color.red, 0) : color.new(color.red, 30))

                // Filter and add
                if agreement >= minAgreement and ensembleStrength >= minStrength
                    ensembleLevel = EnsembleLevel.new(clusterPrice, clusterType, ensembleStrength, agreement, sources, confidence, levelColor)
                    array.push(ensembleLevels, ensembleLevel)

        // Sort by strength
        ensembleSize = array.size(ensembleLevels)
        if ensembleSize > 1
            for i = 0 to ensembleSize - 2
                for j = i + 1 to ensembleSize - 1
                    if array.get(ensembleLevels, j).ensembleStrength > array.get(ensembleLevels, i).ensembleStrength
                        temp = array.get(ensembleLevels, i)
                        array.set(ensembleLevels, i, array.get(ensembleLevels, j))
                        array.set(ensembleLevels, j, temp)

// ============================= VISUALIZATION ================================

if (barstate.isconfirmed or barstate.islast) and array.size(ensembleLevels) > 0
    levelsToShow = math.min(maxLevels, array.size(ensembleLevels))

    for i = 0 to levelsToShow - 1
        level = array.get(ensembleLevels, i)

        lineWidth = level.agreementCount == 4 ? 3 : level.agreementCount == 3 ? 2 : 1

        line.new(bar_index - 50, level.price, bar_index + 20, level.price,
             color=level.levelColor, width=lineWidth)

        if showLabels
            labelText = str.tostring(math.round(level.ensembleStrength))
            if showSources
                labelText += " (" + level.sources + ")"

            labelStyle = level.levelType == "Support" ? label.style_label_up : label.style_label_down

            label.new(bar_index + 10, level.price, labelText,
                 style=labelStyle, color=level.levelColor, textcolor=color.white,
                 size=level.agreementCount >= 3 ? size.normal : size.small)

// Info table
if showTable
    var table info = table.new(position.top_right, 2, 6, border_width=1)

    if barstate.islast
        table.cell(info, 0, 0, "S/R Ensemble V2", text_color=color.white,
             bgcolor=color.new(color.blue, 30), text_size=size.normal)
        table.merge_cells(info, 0, 0, 1, 0)

        table.cell(info, 0, 1, "Total Levels:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 1, str.tostring(array.size(ensembleLevels)),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        table.cell(info, 0, 2, "Showing:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 2, str.tostring(math.min(maxLevels, array.size(ensembleLevels))),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        if array.size(ensembleLevels) > 0
            topLevel = array.get(ensembleLevels, 0)

            table.cell(info, 0, 3, "Strongest:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 3, str.tostring(topLevel.price, format.mintick),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 4, "Strength:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 4, str.tostring(math.round(topLevel.ensembleStrength)),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 5, "Agreement:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 5, str.tostring(topLevel.agreementCount) + "/4",
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

// ============================= ALERTS =======================================

highConfNearby = false
if array.size(ensembleLevels) > 0
    for i = 0 to math.min(3, array.size(ensembleLevels) - 1)
        level = array.get(ensembleLevels, i)
        if level.agreementCount >= 3
            distance = level_lib.calculateDistance(level.price, close)
            if distance < 0.01
                highConfNearby := true
                break

if highConfNearby and not highConfNearby[1]
    alert("Price near high-confidence S/R on " + syminfo.ticker, alert.freq_once_per_bar_close)

perfectAgree = false
if array.size(ensembleLevels) > 0
    topLevel = array.get(ensembleLevels, 0)
    if topLevel.agreementCount == 4
        distance = level_lib.calculateDistance(topLevel.price, close)
        if distance < 0.015
            perfectAgree := true

if perfectAgree and not perfectAgree[1]
    topLevel = array.get(ensembleLevels, 0)
    alert("PERFECT AGREEMENT: " + topLevel.levelType + " at " + str.tostring(topLevel.price, format.mintick) +
          " on " + syminfo.ticker, alert.freq_once_per_bar_close)
