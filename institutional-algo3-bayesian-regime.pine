//@version=5
indicator(title="Institutional Algo 3: Bayesian Regime Classifier", shorttitle="Inst Bayesian", overlay=false, precision=0, max_bars_back=500)

// ============================================================================
// ALGORITHM 3: INTRABAR DISTRIBUTION & BAYESIAN REGIME CLASSIFIER
// ============================================================================
// Most sophisticated algorithm combining intrabar analysis with regime-aware
// Bayesian scoring for institutional detection
// ============================================================================

// ============================= INPUTS =======================================

// Intrabar Analysis
lowerTimeframe = input.timeframe("5", "Lower Timeframe for Intrabar Analysis", group="Intrabar Settings", tooltip="Timeframe to analyze candle internals (5min recommended for hourly/daily charts)")
intrabarLookback = input.int(50, "Intrabar Statistical Lookback", minval=20, maxval=200, group="Intrabar Settings")

// Regime Detection
regimeLength = input.int(100, "Regime Detection Length", minval=50, maxval=200, group="Regime Settings")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Settings")
adxLength = input.int(14, "ADX Length", minval=7, maxval=50, group="Regime Settings")
adxTrendThreshold = input.int(25, "ADX Trending Threshold", minval=15, maxval=40, group="Regime Settings")
adxRangeThreshold = input.int(20, "ADX Ranging Threshold", minval=10, maxval=25, group="Regime Settings")

// Bayesian Priors (regime-specific)
priorRangingLowVol = input.float(0.40, "Prior: Ranging/LowVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors", tooltip="Highest institutional activity expected")
priorTrendingLowVol = input.float(0.30, "Prior: Trending/LowVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors")
priorRangingHighVol = input.float(0.25, "Prior: Ranging/HighVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors")
priorTrendingHighVol = input.float(0.15, "Prior: Trending/HighVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors", tooltip="Lowest - more noise")

// Feature Detection Thresholds
volumeMultiplier = input.float(2.0, "High Volume Threshold", minval=1.5, maxval=5.0, step=0.1, group="Feature Detection")
efficiencyMultiplier = input.float(1.5, "High Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Feature Detection")
balanceThreshold = input.float(60, "Intrabar Balance Threshold", minval=50, maxval=80, step=5, group="Feature Detection")
consistencyThreshold = input.float(60, "Volume Consistency Threshold", minval=50, maxval=80, step=5, group="Feature Detection")

// Scoring
scoreThreshold = input.int(70, "Score Threshold (Institutional)", minval=50, maxval=90, group="Scoring")

// Visualization
showTable = input.bool(true, "Show Info Table", group="Visualization")
showRegimeBackground = input.bool(true, "Show Regime Background", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")

// Debug
debugMode = input.bool(false, "Debug Mode", group="Debug")

// ============================= REGIME DETECTION =============================

// ATR-based volatility regime
currentATR = ta.atr(atrLength)
avgATR = ta.sma(ta.atr(atrLength), regimeLength)
atrRatio = avgATR > 0 and not na(avgATR) ? currentATR / avgATR : 1.0

isHighVol = atrRatio > 1.3
isLowVol = atrRatio < 0.7

// ADX-based trend regime
[diPlus, diMinus, adxValue] = ta.dmi(adxLength, adxLength)
isTrending = adxValue > adxTrendThreshold
isRanging = adxValue < adxRangeThreshold

// Classify regime
regime = ""
regimeColor = color.gray

if isTrending and isHighVol
    regime := "TrendingHighVol"
    regimeColor := color.new(color.red, 80)
else if isTrending and isLowVol
    regime := "TrendingLowVol"
    regimeColor := color.new(color.orange, 80)
else if isRanging and isHighVol
    regime := "RangingHighVol"
    regimeColor := color.new(color.yellow, 80)
else if isRanging and isLowVol
    regime := "RangingLowVol"
    regimeColor := color.new(color.green, 80)
else
    regime := "Neutral"
    regimeColor := color.new(color.gray, 90)

// Set prior probability based on regime
priorProbability = switch regime
    "RangingLowVol" => priorRangingLowVol
    "TrendingLowVol" => priorTrendingLowVol
    "RangingHighVol" => priorRangingHighVol
    "TrendingHighVol" => priorTrendingHighVol
    => 0.20

// ============================= INTRABAR ANALYSIS ============================

// Initialize variables for intrabar metrics
var float balanceScore = 50.0
var float consistencyScore = 50.0
var int totalIntrabars = 0
var string intrabarPattern = "Neutral"

// Request lower timeframe data
[ltfOpen, ltfHigh, ltfLow, ltfClose, ltfVolume] = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, [open, high, low, close, volume])

// Analyze intrabar data if available
if array.size(ltfClose) > 0 and array.size(ltfOpen) > 0
    totalIntrabars := math.min(array.size(ltfClose), array.size(ltfOpen))

    // Count directional bars
    buyBars = 0
    sellBars = 0

    for i = 0 to totalIntrabars - 1
        ltfC = array.get(ltfClose, i)
        ltfO = array.get(ltfOpen, i)

        if ltfC > ltfO
            buyBars += 1
        else if ltfC < ltfO
            sellBars += 1

    // Balance ratio (institutional = balanced, retail = one-sided)
    balanceRatio = totalIntrabars > 0 ? math.abs(buyBars - sellBars) / totalIntrabars : 0.5
    balanceScore := (1 - balanceRatio) * 100

    // Determine intrabar pattern
    if balanceScore > 70
        intrabarPattern := "Balanced (Inst)"
    else if buyBars > sellBars * 1.5
        intrabarPattern := "Buy Heavy (Retail)"
    else if sellBars > buyBars * 1.5
        intrabarPattern := "Sell Heavy (Retail)"
    else
        intrabarPattern := "Mixed"

    // Volume distribution consistency
    if array.size(ltfVolume) > 0
        volumeStdDev = array.stdev(ltfVolume)
        volumeMean = array.avg(ltfVolume)

        // Coefficient of variation (prevent division by zero)
        volumeCV = volumeMean > 0 ? volumeStdDev / volumeMean : 1.0

        // Low CV = steady accumulation, High CV = spikey retail activity
        consistencyScore := volumeCV < 0.6 ? 100.0 : math.max(0, 100 - volumeCV * 100)

// ============================= FEATURE DETECTION ============================

// Feature 1: High Volume
avgVolume = ta.sma(volume, 20)
highVolume = avgVolume > 0 and not na(avgVolume) and volume > (avgVolume * volumeMultiplier)

// Feature 2: High Efficiency (volume per price movement)
priceRange = high - low
minRange = close * 0.0001
volumeEfficiency = priceRange > minRange ? volume / priceRange : volume / minRange
avgVolumeEfficiency = ta.sma(volumeEfficiency, 20)
highEfficiency = avgVolumeEfficiency > 0 and not na(avgVolumeEfficiency) and volumeEfficiency > (avgVolumeEfficiency * efficiencyMultiplier)

// Feature 3: Balanced Intrabars
balancedIntrabars = balanceScore > balanceThreshold

// Feature 4: Consistent Volume Distribution
consistentVolume = consistencyScore > consistencyThreshold

// ============================= LIKELIHOOD CALCULATION =======================

// Regime-specific likelihoods
likelihoodGivenInst = 1.0
likelihoodGivenNotInst = 1.0

if regime == "RangingLowVol"
    if highVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.30
    if highEfficiency
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.25
    if balancedIntrabars
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35
    if consistentVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.30

else if regime == "TrendingHighVol"
    if highVolume
        likelihoodGivenInst *= 0.85
        likelihoodGivenNotInst *= 0.60
    if highEfficiency
        likelihoodGivenInst *= 0.60
        likelihoodGivenNotInst *= 0.40
    if balancedIntrabars
        likelihoodGivenInst *= 0.50
        likelihoodGivenNotInst *= 0.45
    if consistentVolume
        likelihoodGivenInst *= 0.60
        likelihoodGivenNotInst *= 0.50

else if regime == "TrendingLowVol"
    if highVolume
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.35
    if highEfficiency
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.30
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35

else if regime == "RangingHighVol"
    if highVolume
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.45
    if highEfficiency
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.35
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.40

else
    if highVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.40
    if highEfficiency
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.40

// ============================= BAYESIAN CALCULATION =========================

// Bayes Theorem: P(Inst|Features) = P(Features|Inst) * P(Inst) / P(Features)
numerator = likelihoodGivenInst * priorProbability
denominator = (likelihoodGivenInst * priorProbability) + (likelihoodGivenNotInst * (1 - priorProbability))

posteriorProbability = denominator > 0 ? numerator / denominator : 0.0

// Convert to 0-100 score
bayesianScore = posteriorProbability * 100

// Confidence boost if multiple strong signals align
confidenceBoost = 0.0
signalCount = 0

if highVolume
    signalCount += 1
if highEfficiency
    signalCount += 1
if balancedIntrabars
    signalCount += 1
if consistentVolume
    signalCount += 1

if signalCount >= 3
    confidenceBoost := 10.0
else if signalCount >= 2
    confidenceBoost := 5.0

finalScore = math.min(100, bayesianScore + confidenceBoost)
isInstitutional = finalScore >= scoreThreshold

// Determine institutional type
institutionalType = ""
if isInstitutional
    if intrabarPattern == "Balanced (Inst)" and regime == "RangingLowVol"
        institutionalType := "Accumulation"
    else if highVolume and regime == "TrendingHighVol"
        institutionalType := "Distribution"
    else
        institutionalType := "Mixed"

// ============================= VISUALIZATION ================================

// Color gradient
scoreColor = finalScore >= 70 ? color.new(color.green, 0) : finalScore >= 50 ? color.new(color.yellow, 0) : finalScore >= 30 ? color.new(color.orange, 0) : color.new(color.red, 0)

// Main Bayesian score histogram
plot(finalScore, "Bayesian Score", color=scoreColor, style=plot.style_histogram, linewidth=3)

// Component scores
plot(bayesianScore, "Raw Bayesian", color=color.new(color.blue, 50), linewidth=1)
plot(priorProbability * 100, "Prior", color=color.new(color.purple, 70), linewidth=1, style=plot.style_circles)

// Reference lines
hline(scoreThreshold, "Threshold", color=color.new(color.white, 50), linestyle=hline.style_dashed)
hline(50, "Midline", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Regime background
bgcolor(showRegimeBackground ? regimeColor : na, title="Regime Background")

// Chart markers
plotshape(showMarkers and isInstitutional and institutionalType == "Accumulation" ? finalScore : na, "Accumulation", shape.diamond, location.bottom, color.new(color.green, 0), size=size.small)
plotshape(showMarkers and isInstitutional and institutionalType == "Distribution" ? finalScore : na, "Distribution", shape.diamond, location.top, color.new(color.red, 0), size=size.small)

// ============================= INFO TABLE ===================================

if showTable
    var table infoTable = table.new(position.top_right, 2, 14, border_width=1)

    if barstate.islast
        // Header
        table.cell(infoTable, 0, 0, "Bayesian Regime Classifier", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
        table.merge_cells(infoTable, 0, 0, 1, 0)

        // Current Status
        table.cell(infoTable, 0, 1, "Bayesian Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(infoTable, 1, 1, str.tostring(math.round(finalScore, 0)), text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        table.cell(infoTable, 0, 2, "Confidence:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        confLevel = signalCount >= 3 ? "High" : signalCount >= 2 ? "Medium" : "Low"
        table.cell(infoTable, 1, 2, confLevel, text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        table.cell(infoTable, 0, 3, "Type:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(infoTable, 1, 3, institutionalType, text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        // Regime Section
        table.cell(infoTable, 0, 4, "Regime:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(infoTable, 0, 4, 1, 4)

        table.cell(infoTable, 0, 5, "Classification:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 5, regime, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 6, "Prior Probability:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 6, str.tostring(priorProbability * 100, "#") + "%", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 7, "ATR Ratio:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 7, str.tostring(atrRatio, "#.##"), text_color=isHighVol ? color.red : isLowVol ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 8, "ADX:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 8, str.tostring(adxValue, "#.#"), text_color=isTrending ? color.orange : color.green, bgcolor=color.new(color.gray, 80), text_size=size.small)

        // Features Section
        table.cell(infoTable, 0, 9, "Detected Features:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(infoTable, 0, 9, 1, 9)

        table.cell(infoTable, 0, 10, "High Volume:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 10, highVolume ? "✓" : "✗", text_color=highVolume ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 11, "High Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 11, highEfficiency ? "✓" : "✗", text_color=highEfficiency ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 12, "Balanced Intrabars:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 12, balancedIntrabars ? "✓ (" + str.tostring(balanceScore, "#") + ")" : "✗", text_color=balancedIntrabars ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 13, "Consistent Volume:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 13, consistentVolume ? "✓ (" + str.tostring(consistencyScore, "#") + ")" : "✗", text_color=consistentVolume ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

// ============================= DEBUG TABLE ==================================

if debugMode
    var table debugTable = table.new(position.bottom_right, 2, 7, border_width=1)

    if barstate.islast
        table.cell(debugTable, 0, 0, "DEBUG: Bayesian", text_color=color.black, bgcolor=color.yellow, text_size=size.small)
        table.merge_cells(debugTable, 0, 0, 1, 0)

        table.cell(debugTable, 0, 1, "L(F|Inst):", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 1, str.tostring(likelihoodGivenInst, "#.###"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 2, "L(F|NotInst):", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 2, str.tostring(likelihoodGivenNotInst, "#.###"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 3, "Intrabars:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 3, str.tostring(totalIntrabars), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 4, "Pattern:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 4, intrabarPattern, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 5, "Balance Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 5, str.tostring(balanceScore, "#.#"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 6, "Signal Count:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 6, str.tostring(signalCount) + " / 4", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

// ============================= ALERTS =======================================

alertcondition(ta.crossover(finalScore, scoreThreshold), "Bayesian Institutional Signal", "BAYESIAN: High probability institutional " + institutionalType + " on {{ticker}} (Score: " + str.tostring(finalScore, "#") + ", Regime: " + regime + ")")

alertcondition(signalCount == 4 and finalScore > scoreThreshold and not (finalScore[1] > scoreThreshold), "All Features Aligned", "VERY HIGH CONFIDENCE: All 4 features detected on {{ticker}} in " + regime + " regime")

alertcondition(regime == "RangingLowVol" and finalScore > 80, "Optimal Regime Signal", "OPTIMAL CONDITIONS: Institutional activity in ideal regime on {{ticker}} (Score: " + str.tostring(finalScore, "#") + ")")
