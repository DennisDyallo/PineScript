//@version=5
indicator(title="Institutional Algo 2: Multi-Timeframe Volume Convergence", shorttitle="Inst MTF Convergence", overlay=false, precision=0)

// ============================================================================
// ALGORITHM 2: MULTI-TIMEFRAME VOLUME CONVERGENCE DETECTOR
// ============================================================================
// Identifies sustained institutional campaigns by detecting volume increases
// across multiple timeframes simultaneously
// ============================================================================

// ============================= INPUTS =======================================

// Timeframe Settings
currentTF = timeframe.period
manualHTF1 = input.timeframe("", "Higher Timeframe 1 (auto if empty)", group="Timeframe Settings", tooltip="Leave empty for auto-detection")
manualHTF2 = input.timeframe("", "Higher Timeframe 2 (auto if empty)", group="Timeframe Settings", tooltip="Leave empty for auto-detection")

// Volume Settings
volumeLookback = input.int(20, "Volume Lookback Period", minval=10, maxval=100, group="Volume Settings")
volumeThreshold1 = input.float(1.5, "Volume Threshold (Current TF)", minval=1.0, maxval=5.0, step=0.1, group="Volume Settings")
volumeThreshold2 = input.float(1.5, "Volume Threshold (HTF1)", minval=1.0, maxval=5.0, step=0.1, group="Volume Settings")
volumeThreshold3 = input.float(1.5, "Volume Threshold (HTF2)", minval=1.0, maxval=5.0, step=0.1, group="Volume Settings")

// Pattern Detection
divergenceThreshold = input.float(0.2, "Base Divergence Threshold", minval=0.0, maxval=1.0, step=0.05, group="Pattern Settings", tooltip="Base threshold - will be adjusted by ATR regime")
useAdaptiveThreshold = input.bool(true, "Use Adaptive Threshold", group="Pattern Settings", tooltip="Adjust divergence threshold based on volatility regime")
trendLength = input.int(50, "Trend Detection Length", minval=20, maxval=200, group="Pattern Settings")

// Regime Detection Settings
useRegimeFilter = input.bool(true, "Enable Regime Scoring", group="Regime Settings", tooltip="Award/penalize based on volatility regime")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Settings")
atrLookback = input.int(50, "ATR Regime Lookback", minval=20, maxval=100, group="Regime Settings")

// Scoring Settings
scoreThreshold = input.int(70, "Score Threshold (Institutional)", minval=50, maxval=90, group="Scoring")

// Visualization Settings
showTable = input.bool(true, "Show Info Table", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")
showVolumePlots = input.bool(true, "Show Volume Plots", group="Visualization")

// Debug
debugMode = input.bool(false, "Debug Mode", group="Debug")

// ============================= FUNCTIONS ====================================

// Function to auto-detect next logical timeframe
getHigherTimeframe(baseTF) =>
    string result = ""
    tfInMinutes = timeframe.in_seconds(baseTF) / 60
    if tfInMinutes <= 1
        result := "5"
    else if tfInMinutes <= 3
        result := "15"
    else if tfInMinutes <= 5
        result := "15"
    else if tfInMinutes <= 15
        result := "60"
    else if tfInMinutes <= 30
        result := "60"
    else if tfInMinutes <= 60
        result := "240"
    else if tfInMinutes <= 240
        result := "D"
    else if tfInMinutes < 1440
        result := "D"
    else if baseTF == "D"
        result := "W"
    else if baseTF == "W"
        result := "M"
    else
        result := "M"
    result

// Get second higher timeframe
getSecondHigherTimeframe(baseTF) =>
    firstHTF = getHigherTimeframe(baseTF)
    getHigherTimeframe(firstHTF)

// Auto-detect or use manual timeframes
higherTF1 = manualHTF1 == "" ? getHigherTimeframe(currentTF) : manualHTF1
higherTF2 = manualHTF2 == "" ? getSecondHigherTimeframe(currentTF) : manualHTF2

// ============================= CALCULATIONS =================================

// CURRENT TIMEFRAME ANALYSIS
currentVolume = volume
currentAvgVolume = ta.sma(volume, volumeLookback)
currentRelVol = currentAvgVolume > 0 and not na(currentAvgVolume) ? currentVolume / currentAvgVolume : 1.0

// HIGHER TIMEFRAME 1 ANALYSIS
[htf1Volume, htf1AvgVolume] = request.security(syminfo.tickerid, higherTF1, [volume, ta.sma(volume, volumeLookback)], lookahead=barmerge.lookahead_off)
htf1RelVol = htf1AvgVolume > 0 and not na(htf1AvgVolume) and not na(htf1Volume) ? htf1Volume / htf1AvgVolume : 1.0

// HIGHER TIMEFRAME 2 ANALYSIS
[htf2Volume, htf2AvgVolume] = request.security(syminfo.tickerid, higherTF2, [volume, ta.sma(volume, volumeLookback)], lookahead=barmerge.lookahead_off)
htf2RelVol = htf2AvgVolume > 0 and not na(htf2AvgVolume) and not na(htf2Volume) ? htf2Volume / htf2AvgVolume : 1.0

// ============================= REGIME DETECTION =============================

// ATR-based volatility regime
currentATR = ta.atr(atrLength)
avgATR = ta.sma(ta.atr(atrLength), atrLookback)
atrRatio = avgATR > 0 and not na(avgATR) ? currentATR / avgATR : 1.0

// Classify volatility regime
isHighVol = atrRatio > 1.3  // Current volatility >30% above average
isLowVol = atrRatio < 0.7   // Current volatility <30% below average
isNormalVol = not isHighVol and not isLowVol

// Regime label
regimeName = isHighVol ? "High Vol" : isLowVol ? "Low Vol" : "Normal Vol"

// Adaptive divergence threshold based on regime
adaptiveDivergence = divergenceThreshold
if useAdaptiveThreshold
    if isHighVol
        adaptiveDivergence := math.min(0.5, divergenceThreshold * 1.5)  // Wider threshold in high vol
    else if isLowVol
        adaptiveDivergence := math.max(0.1, divergenceThreshold * 0.8)  // Tighter threshold in low vol
    adaptiveDivergence

// ============================= SCORING ======================================

// 1. VOLUME CONVERGENCE SCORE (0-35 points)
convergenceScore = 0.0
if currentRelVol > volumeThreshold1 and htf1RelVol > volumeThreshold2 and htf2RelVol > volumeThreshold3
    convergenceScore := 35.0
else if (currentRelVol > volumeThreshold1 and htf1RelVol > volumeThreshold2) or (htf1RelVol > volumeThreshold2 and htf2RelVol > volumeThreshold3) or (currentRelVol > volumeThreshold1 and htf2RelVol > volumeThreshold3)
    convergenceScore := 22.0
else if currentRelVol > volumeThreshold1 or htf1RelVol > volumeThreshold2 or htf2RelVol > volumeThreshold3
    convergenceScore := 9.0

// 2. VOLUME PATTERN SCORE - Building Campaign (0-17 points)
volumePatternScore = 0.0
if htf2RelVol > htf1RelVol and htf1RelVol > currentRelVol and convergenceScore > 18
    volumePatternScore := 17.0
else if htf2RelVol > htf1RelVol or htf1RelVol > currentRelVol
    volumePatternScore := 9.0

// 3. PRICE ACTION CONFIRMATION (0-28 points)
currentRange = (high - low) / close
avgRange = ta.sma(currentRange, volumeLookback)
rangeRatio = avgRange > 0 and not na(avgRange) ? currentRange / avgRange : 1.0

priceScore = 0.0
patternLabel = ""
if rangeRatio < (1.0 + adaptiveDivergence) and convergenceScore > 18
    priceScore := 28.0
    patternLabel := "Accumulation"
else if rangeRatio > (1.0 + adaptiveDivergence) and convergenceScore > 18
    priceScore := 19.0
    patternLabel := "Distribution/Breakout"
else
    patternLabel := "Neutral"

// 4. TREND CONFIRMATION (0-10 points)
htf1Close = request.security(syminfo.tickerid, higherTF1, close, lookahead=barmerge.lookahead_off)
htf1SMA = request.security(syminfo.tickerid, higherTF1, ta.sma(close, trendLength), lookahead=barmerge.lookahead_off)
htf1Trend = not na(htf1Close) and not na(htf1SMA) and htf1Close > htf1SMA

trendScore = htf1Trend and convergenceScore > 18 ? 10.0 : 0.0

// 5. REGIME SCORING (0-10 points with transition detection)
// Low volatility = best for detecting institutional activity (less noise)
// High volatility = worst (more false positives, retail noise)

// Detect regime transitions (reduce confidence when regime is unstable)
atrChange = math.abs(atrRatio - atrRatio[5])
isTransitioning = atrChange > 0.2

regimeScore = 0.0
regimeLabel = ""
if useRegimeFilter
    if isTransitioning
        regimeScore := 5.0   // Reduced confidence during transitions
        regimeLabel := regimeName + " (Transitioning)"
    else if isLowVol
        regimeScore := 10.0  // Best regime: Low vol, institutions stand out
        regimeLabel := regimeName
    else if isNormalVol
        regimeScore := 7.0   // Neutral regime: moderate reliability
        regimeLabel := regimeName
    else if isHighVol
        regimeScore := 0.0   // Worst regime: High vol creates false signals
        regimeLabel := regimeName
else
    regimeLabel := regimeName

// 6. FINAL MTF SCORE (0-100, no capping needed)
mtfScore = convergenceScore + volumePatternScore + priceScore + trendScore + regimeScore
isInstitutional = mtfScore >= scoreThreshold

// ============================= VISUALIZATION ================================

// Color gradient (optimized for dark mode)
scoreColor = mtfScore >= 70 ? color.new(#00ff00, 0) : mtfScore >= 50 ? color.new(#ffeb3b, 0) : mtfScore >= 30 ? color.new(#ff9800, 0) : color.new(#f44336, 0)

// Main MTF score histogram
plot(mtfScore, "MTF Score", color=scoreColor, style=plot.style_histogram, linewidth=3)

// Relative volume plots for each timeframe (bright colors for dark mode)
plot(showVolumePlots ? currentRelVol * 20 : na, "Current TF Vol", color=color.new(#2196f3, 20), linewidth=2)
plot(showVolumePlots ? htf1RelVol * 20 : na, "HTF1 Vol", color=color.new(#9c27b0, 20), linewidth=2)
plot(showVolumePlots ? htf2RelVol * 20 : na, "HTF2 Vol", color=color.new(#e91e63, 20), linewidth=2)

// Reference lines (visible on dark backgrounds)
hline(scoreThreshold, "Threshold", color=color.new(#ffffff, 40), linestyle=hline.style_dashed, linewidth=1)
hline(50, "Midline", color=color.new(#757575, 50), linestyle=hline.style_dotted)
hline(30, "Volume Ref (1.5x)", color=color.new(#616161, 60), linestyle=hline.style_dotted)

// Chart markers (bright colors for dark mode)
plotshape(showMarkers and isInstitutional and patternLabel == "Accumulation" ? mtfScore : na, "Accumulation", shape.circle, location.bottom, color.new(#00ff00, 0), size=size.small)
plotshape(showMarkers and isInstitutional and patternLabel == "Distribution/Breakout" ? mtfScore : na, "Distribution", shape.circle, location.top, color.new(#ff5252, 0), size=size.small)

// Background tint
bgcolor(isInstitutional ? color.new(scoreColor, 90) : na)

// ============================= INFO TABLE ===================================

if showTable
    var table infoTable = table.new(position.top_right, 2, 15, border_width=1)

    if barstate.islast
        // Header (dark mode optimized)
        table.cell(infoTable, 0, 0, "MTF Convergence Analysis", text_color=color.white, bgcolor=color.new(#1976d2, 0), text_size=size.normal)
        table.merge_cells(infoTable, 0, 0, 1, 0)

        // Repainting warning (critical for live bars)
        barStatus = barstate.isconfirmed ? "[CLOSED] ✓ FINAL" : "[OPEN] ⚠️ REPAINT RISK"
        barStatusColor = barstate.isconfirmed ? color.new(#00ff00, 70) : color.new(#ff5252, 70)
        table.cell(infoTable, 0, 1, "Bar Status:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.cell(infoTable, 1, 1, barStatus, text_color=color.white, bgcolor=barStatusColor, text_size=size.small)

        // Current Status (darker backgrounds for visibility on dark mode)
        table.cell(infoTable, 0, 2, "MTF Score:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.cell(infoTable, 1, 2, str.tostring(math.round(mtfScore, 0)), text_color=color.white, bgcolor=color.new(scoreColor, 70), text_size=size.small)

        table.cell(infoTable, 0, 3, "Pattern:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.cell(infoTable, 1, 3, patternLabel, text_color=color.white, bgcolor=color.new(scoreColor, 70), text_size=size.small)

        table.cell(infoTable, 0, 4, "Trend:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.cell(infoTable, 1, 4, htf1Trend ? "Bullish" : "Bearish", text_color=htf1Trend ? #00ff00 : #ff5252, bgcolor=color.new(#424242, 0), text_size=size.small)

        // Regime indicator with transition warning
        regimeColor = isTransitioning ? #ff9800 : isLowVol ? #00ff00 : isHighVol ? #ff5252 : #ffeb3b
        table.cell(infoTable, 0, 5, "Regime:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.cell(infoTable, 1, 5, regimeLabel + " (" + str.tostring(atrRatio, "#.##") + "x)", text_color=regimeColor, bgcolor=color.new(#424242, 0), text_size=size.small)

        // Timeframes Section
        table.cell(infoTable, 0, 6, "Timeframes:", text_color=#ffeb3b, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.merge_cells(infoTable, 0, 6, 1, 6)

        // Current TF
        tfLabel = currentTF
        currentCheck = currentRelVol > volumeThreshold1 ? "✓" : "✗"
        table.cell(infoTable, 0, 7, "Current (" + tfLabel + "):", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 7, currentCheck + " " + str.tostring(currentRelVol, "#.#") + "x", text_color=currentRelVol > volumeThreshold1 ? #00ff00 : #757575, bgcolor=color.new(#303030, 0), text_size=size.small)

        // HTF1
        htf1Check = htf1RelVol > volumeThreshold2 ? "✓" : "✗"
        table.cell(infoTable, 0, 8, "HTF1 (" + higherTF1 + "):", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 8, htf1Check + " " + str.tostring(htf1RelVol, "#.#") + "x", text_color=htf1RelVol > volumeThreshold2 ? #00ff00 : #757575, bgcolor=color.new(#303030, 0), text_size=size.small)

        // HTF2
        htf2Check = htf2RelVol > volumeThreshold3 ? "✓" : "✗"
        table.cell(infoTable, 0, 9, "HTF2 (" + higherTF2 + "):", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 9, htf2Check + " " + str.tostring(htf2RelVol, "#.#") + "x", text_color=htf2RelVol > volumeThreshold3 ? #00ff00 : #757575, bgcolor=color.new(#303030, 0), text_size=size.small)

        // Score Components
        table.cell(infoTable, 0, 10, "Score Breakdown:", text_color=#ffeb3b, bgcolor=color.new(#424242, 0), text_size=size.small)
        table.merge_cells(infoTable, 0, 10, 1, 10)

        table.cell(infoTable, 0, 11, "Convergence:", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 11, str.tostring(convergenceScore, "#"), text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)

        table.cell(infoTable, 0, 12, "Pattern:", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 12, str.tostring(volumePatternScore, "#"), text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)

        table.cell(infoTable, 0, 13, "Price Action:", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 13, str.tostring(priceScore, "#"), text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)

        table.cell(infoTable, 0, 14, "Regime:", text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)
        table.cell(infoTable, 1, 14, str.tostring(regimeScore, "#"), text_color=color.white, bgcolor=color.new(#303030, 0), text_size=size.small)

// ============================= DEBUG TABLE ==================================

if debugMode
    var table debugTable = table.new(position.bottom_right, 2, 6, border_width=1)

    if barstate.islast
        table.cell(debugTable, 0, 0, "DEBUG: MTF Data", text_color=color.black, bgcolor=#ffeb3b, text_size=size.small)
        table.merge_cells(debugTable, 0, 0, 1, 0)

        table.cell(debugTable, 0, 1, "Current Vol:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)
        table.cell(debugTable, 1, 1, str.tostring(currentVolume, "#"), text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)

        table.cell(debugTable, 0, 2, "HTF1 Vol:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)
        table.cell(debugTable, 1, 2, str.tostring(htf1Volume, "#"), text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)

        table.cell(debugTable, 0, 3, "HTF2 Vol:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)
        table.cell(debugTable, 1, 3, str.tostring(htf2Volume, "#"), text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)

        table.cell(debugTable, 0, 4, "Range Ratio:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)
        table.cell(debugTable, 1, 4, str.tostring(rangeRatio, "#.##"), text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)

        table.cell(debugTable, 0, 5, "Convergence:", text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)
        convergeText = convergenceScore == 40 ? "All 3 TF" : convergenceScore == 25 ? "2 TF" : convergenceScore == 10 ? "1 TF" : "None"
        table.cell(debugTable, 1, 5, convergeText, text_color=color.white, bgcolor=color.new(#424242, 0), text_size=size.tiny)

// ============================= ALERTS =======================================

// MTF Convergence Detected
if ta.crossover(mtfScore, scoreThreshold)
    alert("MULTI-TIMEFRAME: Institutional " + patternLabel + " detected on " + syminfo.ticker + " (Score: " + str.tostring(math.round(mtfScore, 0)) + ")", alert.freq_once_per_bar_close)

// MTF Convergence Ended
if ta.crossunder(mtfScore, scoreThreshold)
    alert("MTF institutional activity ended on " + syminfo.ticker, alert.freq_once_per_bar_close)

// All Timeframes Aligned (highest confidence)
if convergenceScore == 40 and mtfScore > scoreThreshold and not (mtfScore[1] > scoreThreshold)
    alert("VERY HIGH CONFIDENCE: All 3 timeframes show institutional activity on " + syminfo.ticker + " (" + patternLabel + ")", alert.freq_once_per_bar_close)
