//@version=5
indicator("S/R Detection Ensemble", shorttitle="S/R Ensemble", overlay=true, max_lines_count=50, max_labels_count=20, max_boxes_count=10)

// ============================================================================
// S/R DETECTION ENSEMBLE: COMBINES ALL 4 ALGORITHMS
// ============================================================================
// Weighted combination of:
// 1. Volume Profile Detection (30%)
// 2. Statistical Peak/Trough (25%)
// 3. Multi-Timeframe Confluence (35%)
// 4. Order Book Reconstruction (10%)
// Target Accuracy: 80-90% for ensemble-validated levels
// ============================================================================

// ============================= INPUTS =======================================

// Ensemble Weighting
weight_volumeProfile = input.float(0.30, "Weight: Volume Profile", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_statistical = input.float(0.25, "Weight: Statistical Peaks", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_mtf = input.float(0.35, "Weight: MTF Confluence", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_orderBook = input.float(0.10, "Weight: Order Book", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")

// Algorithm Selection
enableAlgo1 = input.bool(true, "Enable Volume Profile", group="Algorithm Selection")
enableAlgo2 = input.bool(true, "Enable Statistical Peaks", group="Algorithm Selection")
enableAlgo3 = input.bool(true, "Enable MTF Confluence", group="Algorithm Selection")
enableAlgo4 = input.bool(true, "Enable Order Book", group="Algorithm Selection")

// General Settings
ensembleMinStrength = input.int(70, "Ensemble Strength Threshold", minval=50, maxval=90, group="Ensemble Settings", tooltip="Minimum weighted score to display level")
maxEnsembleLevels = input.int(8, "Max Ensemble Levels", minval=5, maxval=15, group="Ensemble Settings")
showAgreementCount = input.bool(true, "Show Agreement Count", group="Display", tooltip="Show how many algos agree on each level")
showStrengthLabels = input.bool(true, "Show Strength Labels", group="Display")

// Individual Algorithm Parameters (simplified for ensemble)
vpLookback = input.int(150, "VP: Lookback", minval=50, maxval=300, group="Algo Parameters")
vpBins = input.int(30, "VP: Price Bins", minval=20, maxval=50, group="Algo Parameters")
swingBars = input.int(10, "Stat/MTF: Swing Bars", minval=5, maxval=20, group="Algo Parameters")
obLookback = input.int(80, "OB: Lookback", minval=50, maxval=150, group="Algo Parameters")

// Regime Detection (duplicated from TECH-DEBT.md)
useRegimeFilter = input.bool(true, "Enable Regime-Aware Scoring", group="Regime Detection")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Detection")
atrLookback = input.int(50, "ATR Regime Lookback", minval=20, maxval=100, group="Regime Detection")

// ============================= REGIME DETECTION =============================

currentATR = ta.atr(atrLength)
avgATR = ta.sma(ta.atr(atrLength), atrLookback)
atrRatio = avgATR > 0 and not na(avgATR) ? currentATR / avgATR : 1.0

isHighVol = atrRatio > 1.3
isLowVol = atrRatio < 0.7
isNormalVol = not isHighVol and not isLowVol

regimeName = isHighVol ? "High Vol" : isLowVol ? "Low Vol" : "Normal Vol"
regimeMultiplier = isLowVol ? 1.15 : isNormalVol ? 1.0 : 0.85

// ============================= ALGORITHM 1: VOLUME PROFILE ==================

type VPResult
    array<float> prices
    array<float> strengths

getVolume ProfileLevels() =>
    var array<float> vpPrices = array.new_float()
    var array<float> vpStrengths = array.new_float()

    if not enableAlgo1
        VPResult.new(vpPrices, vpStrengths)
    else
        array.clear(vpPrices)
        array.clear(vpStrengths)

        // Build simplified volume profile
        highestPrice = ta.highest(high, vpLookback)
        lowestPrice = ta.lowest(low, vpLookback)
        priceRange = highestPrice - lowestPrice
        binSize = priceRange / vpBins

        var array<float> volumeAtPrice = array.new_float(vpBins, 0.0)
        array.clear(volumeAtPrice)
        for i = 0 to vpBins - 1
            array.push(volumeAtPrice, 0.0)

        // Distribute volume (simplified OHLC method)
        for i = 0 to math.min(vpLookback - 1, bar_index)
            closeBin = math.floor((close[i] - lowestPrice) / binSize)
            closeBin := math.max(0, math.min(vpBins - 1, closeBin))
            array.set(volumeAtPrice, closeBin, array.get(volumeAtPrice, closeBin) + volume[i])

        // Find POC
        maxVol = array.max(volumeAtPrice)
        pocIndex = 0
        for i = 0 to array.size(volumeAtPrice) - 1
            if array.get(volumeAtPrice, i) == maxVol
                pocIndex := i
                break

        pocPrice = lowestPrice + (pocIndex * binSize) + (binSize / 2)
        array.push(vpPrices, pocPrice)
        array.push(vpStrengths, 90.0)  // POC is very strong

        // Find HVNs (simplified)
        hvnThreshold = array.percentile_nearest_rank(volumeAtPrice, 80)
        for i = 1 to array.size(volumeAtPrice) - 2
            if array.get(volumeAtPrice, i) >= hvnThreshold and i != pocIndex
                if array.get(volumeAtPrice, i) > array.get(volumeAtPrice, i-1) and
                   array.get(volumeAtPrice, i) > array.get(volumeAtPrice, i+1)
                    hvnPrice = lowestPrice + (i * binSize) + (binSize / 2)
                    array.push(vpPrices, hvnPrice)
                    array.push(vpStrengths, 70.0)

        VPResult.new(vpPrices, vpStrengths)

vpResult = getVolumeProfileLevels()

// ============================= ALGORITHM 2: STATISTICAL PEAKS ===============

type StatResult
    array<float> prices
    array<float> strengths

getStatisticalLevels() =>
    var array<float> statPrices = array.new_float()
    var array<float> statStrengths = array.new_float()

    if not enableAlgo2
        StatResult.new(statPrices, statStrengths)
    else
        array.clear(statPrices)
        array.clear(statStrengths)

        // Detect swing highs/lows using native functions
        pivotH = ta.pivothigh(high, swingBars, swingBars)
        pivotL = ta.pivotlow(low, swingBars, swingBars)

        // Store recent pivots
        var array<float> recentResistance = array.new_float()
        var array<float> recentSupport = array.new_float()

        if not na(pivotH)
            array.push(recentResistance, pivotH)
            if array.size(recentResistance) > 30
                array.shift(recentResistance)

        if not na(pivotL)
            array.push(recentSupport, pivotL)
            if array.size(recentSupport) > 30
                array.shift(recentSupport)

        // Cluster nearby levels (simplified)
        tolerance = 0.015
        var array<bool> processedR = array.new_bool()
        array.clear(processedR)

        if array.size(recentResistance) > 0
            for i = 0 to array.size(recentResistance) - 1
                array.push(processedR, false)

            for i = 0 to array.size(recentResistance) - 1
                if not array.get(processedR, i)
                    basePrice = array.get(recentResistance, i)
                    clusterCount = 1
                    array.set(processedR, i, true)

                    if i + 1 < array.size(recentResistance)
                        for j = i + 1 to array.size(recentResistance) - 1
                            if not array.get(processedR, j)
                                if math.abs(basePrice - array.get(recentResistance, j)) / basePrice < tolerance
                                    clusterCount += 1
                                    array.set(processedR, j, true)

                    if clusterCount >= 2
                        array.push(statPrices, basePrice)
                        array.push(statStrengths, 60.0 + (clusterCount * 5.0))

        // Same for support (abbreviated for space)
        var array<bool> processedS = array.new_bool()
        array.clear(processedS)

        if array.size(recentSupport) > 0
            for i = 0 to array.size(recentSupport) - 1
                array.push(processedS, false)

            for i = 0 to array.size(recentSupport) - 1
                if not array.get(processedS, i)
                    basePrice = array.get(recentSupport, i)
                    clusterCount = 1
                    array.set(processedS, i, true)

                    if i + 1 < array.size(recentSupport)
                        for j = i + 1 to array.size(recentSupport) - 1
                            if not array.get(processedS, j)
                                if math.abs(basePrice - array.get(recentSupport, j)) / basePrice < tolerance
                                    clusterCount += 1
                                    array.set(processedS, j, true)

                    if clusterCount >= 2
                        array.push(statPrices, basePrice)
                        array.push(statStrengths, 60.0 + (clusterCount * 5.0))

        StatResult.new(statPrices, statStrengths)

statResult = getStatisticalLevels()

// ============================= ALGORITHM 3: MTF CONFLUENCE ==================

type MTFResult
    array<float> prices
    array<float> strengths

getMTFLevels() =>
    var array<float> mtfPrices = array.new_float()
    var array<float> mtfStrengths = array.new_float()

    if not enableAlgo3
        MTFResult.new(mtfPrices, mtfStrengths)
    else
        array.clear(mtfPrices)
        array.clear(mtfStrengths)

        // Get higher timeframe (simplified - use Daily and Weekly for most charts)
        htf1 = timeframe.period == "D" ? "W" : "D"

        // Detect pivots on HTF
        [htfHigh, htfLow] = request.security(syminfo.tickerid, htf1, [high, low], lookahead=barmerge.lookahead_off)
        htfPivotH = ta.pivothigh(htfHigh, 5, 5)
        htfPivotL = ta.pivotlow(htfLow, 5, 5)

        var array<float> htfResistance = array.new_float()
        var array<float> htfSupport = array.new_float()

        if not na(htfPivotH)
            array.push(htfResistance, htfPivotH)
            if array.size(htfResistance) > 20
                array.shift(htfResistance)

        if not na(htfPivotL)
            array.push(htfSupport, htfPivotL)
            if array.size(htfSupport) > 20
                array.shift(htfSupport)

        // Add HTF levels (these get high strength)
        for i = 0 to math.min(9, array.size(htfResistance) - 1)
            array.push(mtfPrices, array.get(htfResistance, i))
            array.push(mtfStrengths, 85.0)  // HTF levels very strong

        for i = 0 to math.min(9, array.size(htfSupport) - 1)
            array.push(mtfPrices, array.get(htfSupport, i))
            array.push(mtfStrengths, 85.0)

        MTFResult.new(mtfPrices, mtfStrengths)

mtfResult = getMTFLevels()

// ============================= ALGORITHM 4: ORDER BOOK ======================

type OBResult
    array<float> prices
    array<float> strengths

getOrderBookLevels() =>
    var array<float> obPrices = array.new_float()
    var array<float> obStrengths = array.new_float()

    if not enableAlgo4
        OBResult.new(obPrices, obStrengths)
    else
        array.clear(obPrices)
        array.clear(obStrengths)

        // Simplified wick analysis
        var array<float> rejectionPrices = array.new_float()
        var array<int> rejectionCounts = array.new_int()

        for i = 0 to math.min(obLookback - 1, bar_index)
            bodySize = math.abs(close[i] - open[i])
            safeBody = math.max(bodySize, close[i] * 0.0001)

            upperWick = high[i] - math.max(open[i], close[i])
            lowerWick = math.min(open[i], close[i]) - low[i]

            // Upper wick rejection
            if upperWick / safeBody > 0.5
                // Check if level exists
                found = false
                if array.size(rejectionPrices) > 0
                    for j = 0 to array.size(rejectionPrices) - 1
                        if math.abs(array.get(rejectionPrices, j) - high[i]) / high[i] < 0.01
                            array.set(rejectionCounts, j, array.get(rejectionCounts, j) + 1)
                            found := true
                            break
                if not found
                    array.push(rejectionPrices, high[i])
                    array.push(rejectionCounts, 1)

            // Lower wick rejection
            if lowerWick / safeBody > 0.5
                found = false
                if array.size(rejectionPrices) > 0
                    for j = 0 to array.size(rejectionPrices) - 1
                        if math.abs(array.get(rejectionPrices, j) - low[i]) / low[i] < 0.01
                            array.set(rejectionCounts, j, array.get(rejectionCounts, j) + 1)
                            found := true
                            break
                if not found
                    array.push(rejectionPrices, low[i])
                    array.push(rejectionCounts, 1)

        // Add levels with multiple rejections
        if array.size(rejectionPrices) > 0
            for i = 0 to array.size(rejectionPrices) - 1
                if array.get(rejectionCounts, i) >= 2
                    array.push(obPrices, array.get(rejectionPrices, i))
                    strength = 50.0 + (array.get(rejectionCounts, i) * 5.0)
                    array.push(obStrengths, math.min(70, strength))

        OBResult.new(obPrices, obStrengths)

obResult = getOrderBookLevels()

// ============================= ENSEMBLE MERGE & SCORING =====================

type EnsembleLevel
    float price
    float ensembleStrength
    int agreementCount
    string agreementSources
    color levelColor

var array<EnsembleLevel> ensembleLevels = array.new<EnsembleLevel>()

if barstate.islast
    array.clear(ensembleLevels)

    // Collect all levels from all algorithms
    type TempLevel
        float price
        float strength
        string source

    var array<TempLevel> allLevels = array.new<TempLevel>()
    array.clear(allLevels)

    // Add VP levels
    if enableAlgo1 and array.size(vpResult.prices) > 0
        for i = 0 to array.size(vpResult.prices) - 1
            temp = TempLevel.new(array.get(vpResult.prices, i), array.get(vpResult.strengths, i), "VP")
            array.push(allLevels, temp)

    // Add Statistical levels
    if enableAlgo2 and array.size(statResult.prices) > 0
        for i = 0 to array.size(statResult.prices) - 1
            temp = TempLevel.new(array.get(statResult.prices, i), array.get(statResult.strengths, i), "ST")
            array.push(allLevels, temp)

    // Add MTF levels
    if enableAlgo3 and array.size(mtfResult.prices) > 0
        for i = 0 to array.size(mtfResult.prices) - 1
            temp = TempLevel.new(array.get(mtfResult.prices, i), array.get(mtfResult.strengths, i), "MTF")
            array.push(allLevels, temp)

    // Add OB levels
    if enableAlgo4 and array.size(obResult.prices) > 0
        for i = 0 to array.size(obResult.prices) - 1
            temp = TempLevel.new(array.get(obResult.prices, i), array.get(obResult.strengths, i), "OB")
            array.push(allLevels, temp)

    // Merge nearby levels (ensemble consensus)
    var array<bool> processed = array.new_bool()
    array.clear(processed)

    mergeTolerance = 0.015

    if array.size(allLevels) > 0
        for i = 0 to array.size(allLevels) - 1
            array.push(processed, false)

        for i = 0 to array.size(allLevels) - 1
            if not array.get(processed, i)
                currentLevel = array.get(allLevels, i)
                var array<TempLevel> cluster = array.new<TempLevel>()
                array.clear(cluster)
                array.push(cluster, currentLevel)
                array.set(processed, i, true)

                // Find nearby levels from other algorithms
                if i + 1 < array.size(allLevels)
                    for j = i + 1 to array.size(allLevels) - 1
                        if not array.get(processed, j)
                            otherLevel = array.get(allLevels, j)
                            distance = math.abs(currentLevel.price - otherLevel.price) / currentLevel.price

                            if distance <= mergeTolerance
                                array.push(cluster, otherLevel)
                                array.set(processed, j, true)

                // Calculate ensemble strength (weighted average)
                totalWeight = 0.0
                weightedStrength = 0.0
                var array<string> sources = array.new_string()
                array.clear(sources)

                if array.size(cluster) > 0
                    for k = 0 to array.size(cluster) - 1
                        member = array.get(cluster, k)
                        weight = member.source == "VP" ? weight_volumeProfile :
                                member.source == "ST" ? weight_statistical :
                                member.source == "MTF" ? weight_mtf :
                                weight_orderBook

                        weightedStrength += member.strength * weight
                        totalWeight += weight

                        // Track unique sources
                        sourceExists = false
                        if array.size(sources) > 0
                            for m = 0 to array.size(sources) - 1
                                if array.get(sources, m) == member.source
                                    sourceExists := true
                                    break
                        if not sourceExists
                            array.push(sources, member.source)

            // Calculate final ensemble strength
            baseStrength = totalWeight > 0 ? weightedStrength / totalWeight : 50.0

            // Agreement bonus (multiple algorithms detecting same level)
            agreementBonus = array.size(sources) >= 3 ? 20.0 :
                            array.size(sources) == 2 ? 10.0 : 0.0

            // Distance weighting
            distance = math.abs(close - currentLevel.price) / close
            distanceMultiplier = distance < 0.05 ? 1.0 : math.max(0.6, 1.0 - distance)

            // Regime adjustment
            regimeAdjustment = useRegimeFilter ? regimeMultiplier : 1.0

            finalStrength = (baseStrength + agreementBonus) * distanceMultiplier * regimeAdjustment
            finalStrength := math.min(100, finalStrength)

            // Build sources string
            sourcesString = ""
            if array.size(sources) > 0
                for k = 0 to array.size(sources) - 1
                    sourcesString += array.get(sources, k)
                    if k < array.size(sources) - 1
                        sourcesString += "+"

            // Color based on agreement
            levelColor = array.size(sources) >= 3 ? color.new(color.blue, 0) :
                        array.size(sources) == 2 ? color.new(color.purple, 20) :
                        color.new(color.gray, 40)

            if finalStrength >= ensembleMinStrength
                ensembleLevel = EnsembleLevel.new(
                     price = currentLevel.price,
                     ensembleStrength = finalStrength,
                     agreementCount = array.size(sources),
                     agreementSources = sourcesString,
                     levelColor = levelColor
                 )
                array.push(ensembleLevels, ensembleLevel)

    // Sort by strength
    if array.size(ensembleLevels) > 1
        for i = 0 to array.size(ensembleLevels) - 1
            for j = 0 to array.size(ensembleLevels) - 2 - i
                if array.get(ensembleLevels, j).ensembleStrength < array.get(ensembleLevels, j + 1).ensembleStrength
                    temp = array.get(ensembleLevels, j)
                    array.set(ensembleLevels, j, array.get(ensembleLevels, j + 1))
                    array.set(ensembleLevels, j + 1, temp)

// ============================= VISUALIZATION ================================

if barstate.islast and array.size(ensembleLevels) > 0
    for i = 0 to math.min(maxEnsembleLevels - 1, array.size(ensembleLevels) - 1)
        level = array.get(ensembleLevels, i)

        // Draw thick ensemble line
        lineWidth = level.agreementCount >= 3 ? 3 : level.agreementCount == 2 ? 2 : 1

        line.new(
             bar_index - 120,
             level.price,
             bar_index + 25,
             level.price,
             color = level.levelColor,
             width = lineWidth,
             style = line.style_solid
         )

        // Draw label
        if showStrengthLabels
            labelText = str.tostring(math.round(level.ensembleStrength))
            if showAgreementCount
                labelText += " [" + str.tostring(level.agreementCount) + "/" + "4]"

            label.new(
                 bar_index + 15,
                 level.price,
                 text = labelText,
                 style = level.price > close ? label.style_label_down : label.style_label_up,
                 color = level.levelColor,
                 textcolor = color.white,
                 size = level.agreementCount >= 3 ? size.normal : size.small,
                 tooltip = "Sources: " + level.agreementSources
             )

// ============================= INFO TABLE ===================================

var table infoTable = table.new(position.top_right, 2, 12, border_width=1)

if barstate.islast
    // Header
    table.cell(infoTable, 0, 0, "S/R ENSEMBLE",
               text_color=color.white, bgcolor=color.new(color.blue, 20), text_size=size.normal)
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Stats
    table.cell(infoTable, 0, 1, "Ensemble Levels:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(math.min(maxEnsembleLevels, array.size(ensembleLevels))),
               text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Agreement breakdown
    agree4 = 0
    agree3 = 0
    agree2 = 0
    for i = 0 to array.size(ensembleLevels) - 1
        level = array.get(ensembleLevels, i)
        if level.agreementCount == 4
            agree4 += 1
        else if level.agreementCount == 3
            agree3 += 1
        else if level.agreementCount == 2
            agree2 += 1

    table.cell(infoTable, 0, 2, "4-Algo Agreement:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(agree4), text_color=color.lime, bgcolor=color.new(color.gray, 80), text_size=size.small)

    table.cell(infoTable, 0, 3, "3-Algo Agreement:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 3, str.tostring(agree3), text_color=color.yellow, bgcolor=color.new(color.gray, 80), text_size=size.small)

    table.cell(infoTable, 0, 4, "2-Algo Agreement:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 4, str.tostring(agree2), text_color=color.orange, bgcolor=color.new(color.gray, 80), text_size=size.small)

    // Active algorithms
    table.cell(infoTable, 0, 5, "Active Algorithms:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.merge_cells(infoTable, 0, 5, 1, 5)

    table.cell(infoTable, 0, 6, "Volume Profile:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 6, enableAlgo1 ? "✓ (" + str.tostring(weight_volumeProfile * 100, "#") + "%)" : "✗",
               text_color=enableAlgo1 ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    table.cell(infoTable, 0, 7, "Statistical:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 7, enableAlgo2 ? "✓ (" + str.tostring(weight_statistical * 100, "#") + "%)" : "✗",
               text_color=enableAlgo2 ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    table.cell(infoTable, 0, 8, "MTF Confluence:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 8, enableAlgo3 ? "✓ (" + str.tostring(weight_mtf * 100, "#") + "%)" : "✗",
               text_color=enableAlgo3 ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    table.cell(infoTable, 0, 9, "Order Book:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 9, enableAlgo4 ? "✓ (" + str.tostring(weight_orderBook * 100, "#") + "%)" : "✗",
               text_color=enableAlgo4 ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    // Regime
    table.cell(infoTable, 0, 10, "Regime:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    regimeColor = isLowVol ? color.green : isHighVol ? color.red : color.orange
    table.cell(infoTable, 1, 10, regimeName + " (" + str.tostring(atrRatio, "#.##") + "x)",
               text_color=regimeColor, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Expected accuracy
    table.cell(infoTable, 0, 11, "Est. Accuracy:",
               text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 11, "80-90%",
               text_color=color.lime, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

// ============================= ALERTS =======================================

// Alert for high-confidence ensemble levels
highConfidenceNearby = false
if array.size(ensembleLevels) > 0
    topLevel = array.get(ensembleLevels, 0)
    if topLevel.agreementCount >= 3 and topLevel.ensembleStrength >= 85
        distance = math.abs(close - topLevel.price) / close
        if distance < 0.01
            highConfidenceNearby := true

if highConfidenceNearby and not highConfidenceNearby[1]
    alert("Price near HIGH CONFIDENCE ensemble S/R level on " + syminfo.ticker, alert.freq_once_per_bar_close)
