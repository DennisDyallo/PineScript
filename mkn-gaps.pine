//@version=6
indicator("MKN: Gaps", overlay = true, max_boxes_count = 500)

// ============================================================================
// BODY-ONLY GAP DETECTION
// ============================================================================
// This indicator detects gaps between candle BODIES (open/close ranges),
// ignoring wicks entirely. This approach:
// - Finds MORE gaps than traditional high/low detection
// - Focuses on where price "committed" vs temporary wick probes
// - Matches visual analysis when wicks are disabled on chart
// - Only closes gaps when bodies (not wicks) enter the gap zone
// ============================================================================

closeGapsPartially = input.bool(false, "Close Gaps Partially", display = display.data_window)
fadeClosedGaps = input.bool(false, "Fade Fully Closed Gaps", display = display.data_window)
fadedOpacity = input.int(85, "Faded Gap Opacity", minval = 70, maxval = 100, display = display.data_window, tooltip = "Opacity for closed gaps (higher = more transparent)")
boxLimitInput = input.int(15, "Max Number of Gaps", minval = 1, maxval = 500, display = display.data_window)
minimalDeviationTooltip = "Specifies the minimal size of detected gaps, as a percentage of the average high-low range for the last 14 bars."
minimalDeviationInput = nz(input.float(30.0, "Minimal Deviation (%)", tooltip = minimalDeviationTooltip, minval=1, maxval=100, display = display.data_window) / 100 * ta.sma(high-low, 14))
limitBoxLengthBoolInput = input.bool(false, "Limit Max Gap Trail Length (bars)", inline = "Length Limit", display = display.data_window)
limitBoxLengthIntInput = input.int(300, "", inline = "Length Limit", minval = 1, display = display.data_window, active = limitBoxLengthBoolInput)

groupName = "Border and fill colors"
colorUpBorderInput = input.color(color.green, "Up Gaps", inline = "Gap Up", group = groupName, display = display.data_window)
colorUpBackgroundInput = input.color(color.new(color.green, 85), "", inline = "Gap Up", group = groupName, display = display.data_window)
colorDownBorderInput = input.color(color.red, "Down Gaps", inline = "Gap Down", group = groupName, display = display.data_window)
colorDownBackgroundInput = input.color(color.new(color.red, 85), "", inline = "Gap Down", group = groupName, display = display.data_window)

type AlertInfo
    int countOpenGap
    int countClosedGap

method hasOpenedGap(AlertInfo this) =>
    this.countOpenGap > 0

method hasClosedGap(AlertInfo this) =>
    this.countClosedGap > 0

AlertInfo alertInfo = AlertInfo.new(0, 0)

//@type A representation of a chart gap and all box drawings that it consists of.
//@field isActive If 'true', the gap has not yet been closed and is still being extended on the chart.
//@field isBull The direction of the gap: 'true' for upward gaps and 'false' for downward ones.
//@field inactiveBoxes An array of all boxes that have been drawn for this gap. The last element of the array is the box on the chart that is currently extended further.
type Gap
    bool isActive
    bool isBull
    array<box> boxes

//@function Deletes all of the boxes that were drawn to represent the gap.
method delete(Gap this) =>
    for _box in this.boxes
        _box.delete()

//@function Closes the gap partially, stopping the previous box and creating a new, smaller box to continue the gap instead.
method partialClose(Gap this) =>
    activeBox = this.boxes.last()
    activeBox.set_extend(extend.none)

    // BODY-ONLY: Use body top/bottom instead of high/low
    bodyTop = math.max(open, close)
    bodyBottom = math.min(open, close)

    top = this.isBull ? activeBox.get_top() : bodyBottom
    bottom = this.isBull ? bodyTop : activeBox.get_bottom()

    this.boxes.push(box.new(
      bar_index,
      top,
      bar_index,
      bottom,
      this.isBull ? colorDownBorderInput : colorUpBorderInput,
      bgcolor = this.isBull ? colorDownBackgroundInput : colorUpBackgroundInput))
    

//@function Closes the gap fully, stopping the box from being extended.
method fullClose(Gap this) =>
    alertInfo.countClosedGap += 1
    activeBox = this.boxes.last()
    activeBox.set_extend(extend.none)
    this.isActive := false
    if closeGapsPartially
        activeBox.delete()
    else if fadeClosedGaps
        // Fade the gap by increasing opacity
        fadedBorderColor = this.isBull ? color.new(color.green, fadedOpacity) : color.new(color.red, fadedOpacity)
        fadedBgColor = this.isBull ? color.new(color.green, fadedOpacity) : color.new(color.red, fadedOpacity)
        activeBox.set_border_color(fadedBorderColor)
        activeBox.set_bgcolor(fadedBgColor)    

method checkForClose(Gap this) =>
    if this.isActive
        activeBox = this.boxes.last()
        top = activeBox.get_top()
        bot = activeBox.get_bottom()
        isBull = this.isBull
        activeBox.set_right(bar_index)

        // BODY-ONLY: Check if body (not wick) enters gap
        bodyTop = math.max(open, close)
        bodyBottom = math.min(open, close)

        // Partial close: body touches gap boundary
        if (bodyTop > bot and isBull) or (bodyBottom < top and not isBull)
            if closeGapsPartially
                this.partialClose()
            else
                this.fullClose()

        // Full close: body completely crosses through gap
        bool forceCloseBoxExceededLengthLimit = (limitBoxLengthBoolInput and bar_index - activeBox.get_left() >= limitBoxLengthIntInput)
        if ((bodyTop > top and isBull) or (bodyBottom < bot and not isBull)) or forceCloseBoxExceededLengthLimit
            this.fullClose()

var allGaps = array.new<Gap>()

// Detect gaps (BODY-ONLY: ignores wicks, focuses on open/close ranges)
// This finds gaps between candle bodies, not high/low extremes
currentBodyTop = math.max(open, close)
currentBodyBottom = math.min(open, close)
previousBodyTop = math.max(open[1], close[1])
previousBodyBottom = math.min(open[1], close[1])

isGapDown = currentBodyTop < previousBodyBottom and previousBodyBottom - currentBodyTop >= minimalDeviationInput
isGapUp = currentBodyBottom > previousBodyTop and currentBodyBottom - previousBodyTop >= minimalDeviationInput
isGap = isGapDown or isGapUp
boxBorderColor = isGapDown ? colorDownBorderInput : colorUpBorderInput
boxBgcolor = isGapDown ? colorDownBackgroundInput : colorUpBackgroundInput

registerNewGap(bool isGapDown) =>
    alertInfo.countOpenGap += 1

    // BODY-ONLY: Use body ranges for gap box coordinates
    // Gap box spans from previous body to current body
    newBox = box.new(
      bar_index - 1,
      (isGapDown ? previousBodyBottom : currentBodyBottom),
      bar_index,
      (isGapDown ? currentBodyTop : previousBodyTop),
      border_color = boxBorderColor,
      bgcolor = boxBgcolor,
      extend = extend.right)

    allGaps.push(Gap.new(true, isGapDown, array.from(newBox)))

    if allGaps.size() > boxLimitInput
        allGaps.shift().delete()

// Detect covering of gaps.
for gap in allGaps
    gap.checkForClose()

// Add a box for each new gap, removing the oldest one if needed.
if isGap    
    registerNewGap(isGapDown)
        
if barstate.islastconfirmedhistory and allGaps.size() == 0
    noGapText = "No gaps found on the current chart. \n The cause could be that some exchanges align the open of new bars on the close of the previous one, resulting in charts with no gaps. Alternatively, your Minimal Deviation might be too high."
    var infoTable = table.new(position.bottom_right, 1, 1)
    table.cell(infoTable, 0, 0, text = noGapText, text_color = chart.bg_color, bgcolor = chart.fg_color)

alertcondition(alertInfo.hasOpenedGap(), "New Gap Appeared", "A new gap has appeared.")
alertcondition(alertInfo.hasClosedGap(), "Gap Closed", "A gap was closed.")
