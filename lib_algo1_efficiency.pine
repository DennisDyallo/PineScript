//@version=5
// @description Library for Algorithm 1: Volume Efficiency & Absorption Detection with 5 pattern types and trend filtering
library("Algo1Efficiency", overlay=false)

import redshad0ww/CoreMath/1 as math_lib
import redshad0ww/VolumeAnalysis/1 as vol_lib
import redshad0ww/TrendDetection/1 as trend_lib

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type Algo1Result
    float score
    string pattern
    bool isAccumulation
    bool isDistribution
    float volumeScore
    float efficiencyScore
    float wickScore
    float controlScore

// ============================================================================
// SIMPLIFIED VERSION (for V1)
// ============================================================================

export calculateSimple(int volumeLookback, float efficiencyThreshold) =>
    var Algo1Result result = Algo1Result.new()

    // Get volume metrics from library
    volMetrics = vol_lib.calculateVolumeMetrics(volumeLookback)
    relativeVolume = volMetrics.relativeVolume
    efficiencyRatio = volMetrics.efficiencyRatio
    volumeScore = volMetrics.volumeScore

    // Calculate efficiency score
    efficiencyScore = efficiencyRatio >= efficiencyThreshold and efficiencyRatio <= 4.0 ?
         math.min(30, (efficiencyRatio - 1.0) * 15.0) : 0.0

    // Price metrics
    priceRange = high - low
    totalWickSize = (high - math.max(open, close)) + (math.min(open, close) - low)
    wickRatio = math_lib.safeDivide(totalWickSize, priceRange, 0.0)
    wickScore = wickRatio > 0.3 ? math.min(20, wickRatio * 40.0) : 0.0

    // Simplified pattern scoring
    closePosition = math_lib.safeDivide(close - low, priceRange, 0.5)
    priceChange3 = (close - close[3]) / close[3] * 100

    controlScore = 0.0
    if closePosition >= 0.35 and closePosition <= 0.65 and relativeVolume > 1.3 and priceChange3 < -1.0
        controlScore := 12.0
    else if closePosition > 0.65 and relativeVolume > 1.8
        controlScore := 10.0
    else if relativeVolume > 1.5
        controlScore := 6.0

    score = math.min(100, volumeScore + efficiencyScore + wickScore + controlScore)

    result.score := score
    result.pattern := "MIXED"
    result.isAccumulation := false
    result.isDistribution := false
    result.volumeScore := volumeScore
    result.efficiencyScore := efficiencyScore
    result.wickScore := wickScore
    result.controlScore := controlScore

    result

// ============================================================================
// FULL VERSION WITH 5 PATTERNS (for V2/V3)
// ============================================================================

export calculateFull(int volumeLookback, float efficiencyThreshold, float minADX, bool useGraduatedTrend = true) =>
    var Algo1Result result = Algo1Result.new()

    // Get volume metrics from library
    volMetrics = vol_lib.calculateVolumeMetrics(volumeLookback)
    relativeVolume = volMetrics.relativeVolume
    efficiencyRatio = volMetrics.efficiencyRatio
    volumeScore = volMetrics.volumeScore

    // Calculate efficiency score
    efficiencyScore = efficiencyRatio >= efficiencyThreshold and efficiencyRatio <= 4.0 ?
         math.min(30, (efficiencyRatio - 1.0) * 15.0) : 0.0

    // Price metrics
    priceRange = high - low
    totalWickSize = (high - math.max(open, close)) + (math.min(open, close) - low)
    wickRatio = math_lib.safeDivide(totalWickSize, priceRange, 0.0)
    wickScore = wickRatio > 0.3 ? math.min(20, wickRatio * 40.0) : 0.0

    // Price context awareness
    closePosition = math_lib.safeDivide(close - low, priceRange, 0.5)
    highest10 = ta.highest(high, 10)
    lowest10 = ta.lowest(low, 10)
    atLocalHigh = high >= highest10[1]
    atLocalLow = low <= lowest10[1]
    priceChange3 = (close - close[3]) / close[3] * 100
    isRising = close > close[3]
    isFalling = close < close[3]

    // 5 DISTINCT PATTERN TYPES
    controlScore = 0.0
    accumulationPattern = false
    distributionPattern = false

    // Pattern 1: Classic Absorption
    if closePosition >= 0.35 and closePosition <= 0.65 and relativeVolume > 1.3 and priceChange3 < -1.0
        controlScore := 12.0
        accumulationPattern := true
    // Pattern 2: Aggressive Accumulation
    else if closePosition > 0.65 and relativeVolume > 1.8
        controlScore := 10.0
        accumulationPattern := true
    // Pattern 3: Distribution into Strength
    else if closePosition > 0.75 and relativeVolume > 2.5 and isRising
        controlScore := 8.0
        distributionPattern := true
    // Pattern 4: Stealth Accumulation
    else if closePosition < 0.40 and atLocalLow and relativeVolume > 1.2 and relativeVolume < 2.0
        controlScore := 7.0
        accumulationPattern := true
    // Pattern 5: High Volume Test
    else if relativeVolume > 1.5
        controlScore := 6.0

    // Trend detection
    [isUptrend, isDowntrend, isRanging] = trend_lib.detectEMATrend(20, 50, 200)
    trendData = trend_lib.detectADXTrend(14, minADX, 35.0)
    isTrending = trendData.isTrending
    isStrongTrend = trendData.isStrongTrend

    // Calculate raw score
    rawScore = volumeScore + efficiencyScore + wickScore + controlScore
    baseScore = math.min(100, math.max(0, rawScore))

    // TREND FILTERING
    trendAligned = (accumulationPattern and isUptrend) or (distributionPattern and isDowntrend)
    trendOpposed = (accumulationPattern and isDowntrend) or (distributionPattern and isUptrend)

    trendMultiplier = 1.0
    if useGraduatedTrend
        // Graduated trend strength (V2/V3 style)
        if trendAligned and isStrongTrend
            trendMultiplier := 1.50
        else if trendAligned and isTrending
            trendMultiplier := 1.25
        else if trendAligned
            trendMultiplier := 1.10
        else if trendOpposed and isStrongTrend
            trendMultiplier := 0.50
        else if trendOpposed
            trendMultiplier := 0.75
    else
        // Simple trend boost (OLD style)
        if trendAligned
            trendMultiplier := 1.10
        else if trendOpposed and isTrending
            trendMultiplier := 0.50

    score = math.min(100, baseScore * trendMultiplier)

    result.score := score
    result.pattern := accumulationPattern ? "ACCUM" : distributionPattern ? "DISTR" : "MIXED"
    result.isAccumulation := accumulationPattern
    result.isDistribution := distributionPattern
    result.volumeScore := volumeScore
    result.efficiencyScore := efficiencyScore
    result.wickScore := wickScore
    result.controlScore := controlScore

    result
