//@version=5
indicator(title="Institutional Algo 4: Ensemble Detector", shorttitle="IA4-Ensemble", overlay=false, precision=0, max_bars_back=500)

// ============================================================================
// LIBRARY IMPORTS
// ============================================================================
import redshad0ww/CoreMath/1 as math_lib
import redshad0ww/RegimeDetection/1 as regime_lib
import redshad0ww/VolumeAnalysis/1 as vol_lib
import redshad0ww/TrendDetection/1 as trend_lib
import redshad0ww/MTFUtils/1 as mtf_lib

// ============================================================================
// ENSEMBLE INDICATOR: COMBINES ALL THREE INSTITUTIONAL ALGORITHMS
// ============================================================================
// Weighted combination using shared libraries:
// 1. Volume Efficiency & Absorption (25%)
// 2. Multi-Timeframe Convergence (35%)
// 3. Bayesian Regime Classifier (40%)
// ============================================================================

// ============================= INPUTS =======================================

// Ensemble Weighting
weight_efficiency = input.float(0.25, "Weight: Volume Efficiency", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_mtf = input.float(0.35, "Weight: MTF Convergence", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")
weight_bayesian = input.float(0.40, "Weight: Bayesian", minval=0.0, maxval=1.0, step=0.05, group="Ensemble Weights")

// General Settings
scoreThreshold = input.int(70, "Ensemble Score Threshold", minval=50, maxval=90, group="Scoring")
enableAlgo1 = input.bool(true, "Enable Algorithm 1 (Efficiency)", group="Algorithm Selection")
enableAlgo2 = input.bool(true, "Enable Algorithm 2 (MTF)", group="Algorithm Selection")
enableAlgo3 = input.bool(true, "Enable Algorithm 3 (Bayesian)", group="Algorithm Selection")

// Visualization
showTable = input.bool(true, "Show Ensemble Table", group="Visualization")
showComponentScores = input.bool(true, "Show Individual Algorithm Scores", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")

// ============================================================================
// ALGORITHM 1: VOLUME EFFICIENCY & ABSORPTION (Library-based)
// ============================================================================

volumeLookback1 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 1: Efficiency")
efficiencyThreshold1 = input.float(1.3, "Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Algo 1: Efficiency")

// Get volume metrics from library
volMetrics1 = vol_lib.calculateVolumeMetrics(volumeLookback1)
volumeScore1 = volMetrics1.volumeScore
efficiencyScore1 = volMetrics1.efficiencyRatio >= efficiencyThreshold1 and volMetrics1.efficiencyRatio <= 4.0 ?
     math.min(30, (volMetrics1.efficiencyRatio - 1.0) * 15.0) : 0.0

// Simplified pattern scoring (keeping core logic)
priceRange1 = high - low
wickRatio1 = math_lib.safeDivide((high - math.max(open, close)) + (math.min(open, close) - low), priceRange1, 0.0)
wickScore1 = wickRatio1 > 0.3 ? math.min(20, wickRatio1 * 40.0) : 0.0

closePosition1 = math_lib.safeDivide(close - low, priceRange1, 0.5)
priceChange3_1 = (close - close[3]) / close[3] * 100

// Simplified pattern detection
controlScore1 = 0.0
if closePosition1 >= 0.35 and closePosition1 <= 0.65 and volMetrics1.relativeVolume > 1.3 and priceChange3_1 < -1.0
    controlScore1 := 12.0
else if closePosition1 > 0.65 and volMetrics1.relativeVolume > 1.8
    controlScore1 := 10.0
else if volMetrics1.relativeVolume > 1.5
    controlScore1 := 6.0

algo1_score = enableAlgo1 ? math.min(100, volumeScore1 + efficiencyScore1 + wickScore1 + controlScore1) : 0.0

// ============================================================================
// ALGORITHM 2: MULTI-TIMEFRAME CONVERGENCE (Library-based)
// ============================================================================

volumeLookback2 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 2: MTF")
volumeThreshold2 = input.float(1.5, "Volume Threshold (All TF)", minval=1.0, maxval=5.0, step=0.1, group="Algo 2: MTF")

// Get higher timeframes from library
higherTF1 = mtf_lib.getHigherTimeframe(timeframe.period)
higherTF2 = mtf_lib.getSecondHigherTimeframe(timeframe.period)

// Current TF volume metrics
volMetrics2 = vol_lib.calculateVolumeMetrics(volumeLookback2)
currentRelVol = volMetrics2.relativeVolume

// HTF volume metrics
[htf1Volume, htf1AvgVolume] = request.security(syminfo.tickerid, higherTF1, [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)
[htf2Volume, htf2AvgVolume] = request.security(syminfo.tickerid, higherTF2, [volume, ta.sma(volume, volumeLookback2)], lookahead=barmerge.lookahead_off)

htf1RelVol = math_lib.safeDivide(htf1Volume, htf1AvgVolume, 1.0)
htf2RelVol = math_lib.safeDivide(htf2Volume, htf2AvgVolume, 1.0)

// MTF Convergence scoring
convergenceScore2 = 0.0
if currentRelVol > volumeThreshold2 and htf1RelVol > volumeThreshold2 and htf2RelVol > volumeThreshold2
    convergenceScore2 := 100.0
else if (currentRelVol > volumeThreshold2 and htf1RelVol > volumeThreshold2) or
     (htf1RelVol > volumeThreshold2 and htf2RelVol > volumeThreshold2)
    convergenceScore2 := 65.0
else if currentRelVol > volumeThreshold2 or htf1RelVol > volumeThreshold2
    convergenceScore2 := 30.0

algo2_score = enableAlgo2 ? convergenceScore2 : 0.0

// ============================================================================
// ALGORITHM 3: BAYESIAN REGIME CLASSIFIER (Library-based)
// ============================================================================

volumeLookback3 = input.int(20, "Volume Lookback", minval=10, maxval=100, group="Algo 3: Bayesian")
volumeMultiplier3 = input.float(2.0, "High Volume Threshold", minval=1.5, maxval=5.0, step=0.1, group="Algo 3: Bayesian")
efficiencyMultiplier3 = input.float(1.5, "High Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Algo 3: Bayesian")

// Get regime from library
regimeData3 = regime_lib.detectRegime(14, 50)
trendData3 = trend_lib.detectADXTrend(14, 25.0, 35.0)

// Get volume metrics
volMetrics3 = vol_lib.calculateVolumeMetrics(volumeLookback3)

// Feature detection
highVolume3 = volMetrics3.relativeVolume > volumeMultiplier3
highEfficiency3 = volMetrics3.efficiencyRatio > efficiencyMultiplier3

// Regime-based priors
priorProbability = 0.20
if regimeData3.isLowVol and not trendData3.isTrending
    priorProbability := 0.40  // Ranging/LowVol - best for institutional
else if regimeData3.isLowVol and trendData3.isTrending
    priorProbability := 0.30  // Trending/LowVol
else if regimeData3.isHighVol and not trendData3.isTrending
    priorProbability := 0.25  // Ranging/HighVol
else if regimeData3.isHighVol and trendData3.isTrending
    priorProbability := 0.15  // Trending/HighVol - worst (noisy)

// Simple Bayesian scoring
likelihood = 0.5
if highVolume3
    likelihood := likelihood * 0.7
if highEfficiency3
    likelihood := likelihood * 0.8

bayesianScore = priorProbability * likelihood * 200.0  // Scale to 0-100
algo3_score = enableAlgo3 ? math.min(100, bayesianScore) : 0.0

// ============================================================================
// ENSEMBLE SCORE CALCULATION
// ============================================================================

// Normalize weights
totalWeight = weight_efficiency + weight_mtf + weight_bayesian
normWeight1 = math_lib.safeDivide(weight_efficiency, totalWeight, 0.33)
normWeight2 = math_lib.safeDivide(weight_mtf, totalWeight, 0.33)
normWeight3 = math_lib.safeDivide(weight_bayesian, totalWeight, 0.34)

// Calculate weighted ensemble score
ensembleScore = (algo1_score * normWeight1) + (algo2_score * normWeight2) + (algo3_score * normWeight3)
isInstitutional = ensembleScore >= scoreThreshold

// Count agreement
agreementCount = 0
if algo1_score >= 70
    agreementCount := agreementCount + 1
if algo2_score >= 70
    agreementCount := agreementCount + 1
if algo3_score >= 70
    agreementCount := agreementCount + 1

agreementLabel = agreementCount == 3 ? "Strong (3/3)" :
     agreementCount == 2 ? "Moderate (2/3)" :
     agreementCount == 1 ? "Weak (1/3)" : "None (0/3)"

// ============================= VISUALIZATION ================================

// Plot ensemble score
hline(scoreThreshold, "Threshold", color=color.white, linestyle=hline.style_dashed)
scoreColor = ensembleScore >= 70 ? color.green : ensembleScore >= 50 ? color.yellow : color.orange
plot(ensembleScore, "Ensemble Score", color=scoreColor, style=plot.style_histogram, linewidth=3)

// Plot individual scores if enabled
plot(showComponentScores ? algo1_score : na, "Algo 1", color=color.new(color.blue, 50), style=plot.style_line)
plot(showComponentScores ? algo2_score : na, "Algo 2", color=color.new(color.purple, 50), style=plot.style_line)
plot(showComponentScores ? algo3_score : na, "Algo 3", color=color.new(color.aqua, 50), style=plot.style_line)

// Chart markers
if showMarkers and isInstitutional
    markerColor = agreementCount >= 2 ? color.new(color.green, 20) : color.new(color.yellow, 20)
    label.new(bar_index, ensembleScore, text=str.tostring(math.round(ensembleScore)) + "\n" + agreementLabel,
         style=label.style_label_up, color=markerColor, textcolor=color.white, size=size.small)

bgcolor(isInstitutional ? color.new(color.green, 92) : na, title="Signal Background")

// ============================= METRICS TABLE ================================

if showTable
    var table ensembleTable = table.new(position.top_right, 2, 11, border_width=2,
         border_color=color.new(color.gray, 50), frame_width=1, frame_color=color.new(color.gray, 50))

    // Header
    table.cell(ensembleTable, 0, 0, "Institutional Ensemble", bgcolor=color.new(color.blue, 70),
         text_color=color.white, text_size=size.normal)
    table.merge_cells(ensembleTable, 0, 0, 1, 0)

    // Ensemble score
    table.cell(ensembleTable, 0, 1, "Ensemble Score:", text_halign=text.align_left)
    table.cell(ensembleTable, 1, 1, str.tostring(math.round(ensembleScore)), text_color=scoreColor)

    // Status
    table.cell(ensembleTable, 0, 2, "Status:", text_halign=text.align_left)
    table.cell(ensembleTable, 1, 2, isInstitutional ? "✓ ACTIVE" : "○ Inactive",
         text_color=isInstitutional ? color.lime : color.new(color.white, 50))

    // Agreement
    table.cell(ensembleTable, 0, 3, "Agreement:", text_halign=text.align_left)
    table.cell(ensembleTable, 1, 3, agreementLabel,
         text_color=agreementCount >= 2 ? color.lime : color.orange)

    // Separator
    table.cell(ensembleTable, 0, 4, "Component Scores:", bgcolor=color.new(color.gray, 70),
         text_color=color.white, text_size=size.small)
    table.merge_cells(ensembleTable, 0, 4, 1, 4)

    // Algorithm scores
    table.cell(ensembleTable, 0, 5, "Efficiency:", text_halign=text.align_left, text_size=size.small)
    table.cell(ensembleTable, 1, 5, str.tostring(math.round(algo1_score)) + " (" +
         str.tostring(math.round(normWeight1 * 100)) + "%)", text_size=size.small,
         text_color=algo1_score >= 70 ? color.lime : color.new(color.white, 50))

    table.cell(ensembleTable, 0, 6, "MTF Convergence:", text_halign=text.align_left, text_size=size.small)
    table.cell(ensembleTable, 1, 6, str.tostring(math.round(algo2_score)) + " (" +
         str.tostring(math.round(normWeight2 * 100)) + "%)", text_size=size.small,
         text_color=algo2_score >= 70 ? color.lime : color.new(color.white, 50))

    table.cell(ensembleTable, 0, 7, "Bayesian:", text_halign=text.align_left, text_size=size.small)
    table.cell(ensembleTable, 1, 7, str.tostring(math.round(algo3_score)) + " (" +
         str.tostring(math.round(normWeight3 * 100)) + "%)", text_size=size.small,
         text_color=algo3_score >= 70 ? color.lime : color.new(color.white, 50))

    // Regime info
    table.cell(ensembleTable, 0, 8, "Regime:", bgcolor=color.new(color.gray, 70),
         text_color=color.white, text_size=size.small)
    table.merge_cells(ensembleTable, 0, 8, 1, 8)

    table.cell(ensembleTable, 0, 9, "Volatility:", text_halign=text.align_left, text_size=size.small)
    table.cell(ensembleTable, 1, 9, regimeData3.name, text_size=size.small)

    table.cell(ensembleTable, 0, 10, "ADX:", text_halign=text.align_left, text_size=size.small)
    table.cell(ensembleTable, 1, 10, str.tostring(math.round(trendData3.adxValue, 1)),
         text_size=size.small, text_color=trendData3.isTrending ? color.lime : color.new(color.white, 50))

// ============================= ALERTS =======================================

alertcondition(ta.crossover(ensembleScore, scoreThreshold), title="Ensemble Signal",
     message="Institutional Ensemble score crossed above " + str.tostring(scoreThreshold))

alertcondition(isInstitutional and agreementCount >= 2, title="Strong Agreement",
     message="Strong institutional signal - " + str.tostring(agreementCount) + "/3 algorithms agree")
