//@version=5
indicator(title="Institutional Algo 3: Bayesian Regime Classifier", shorttitle="IA3-BRC", overlay=false, precision=0, max_bars_back=500)

// ============================================================================
// LABEL DOCUMENTATION
// ============================================================================
//
// WHAT THE MARKERS MEAN:
//
// Chart Markers: Diamond shapes (no text labels)
//   - Green diamond (bottom) = Accumulation pattern
//   - Red diamond (top) = Distribution pattern
//   - Position shows final Bayesian probability score (0-100)
//
// Final Score (0-100): Bayesian probability of institutional activity
//   - Uses Bayes' theorem: P(Institutional|Evidence) = P(Evidence|Institutional) × P(Institutional) / P(Evidence)
//   - NOT a simple sum - probabilistic classification
//
// Regime Classification (5 states):
//   1. RangingLowVol (Green background)
//      • Prior probability: 40% (highest institutional activity expected)
//      • ADX < 20, ATR < 0.7× average
//      • Best environment for detecting accumulation/distribution
//
//   2. TrendingLowVol (Orange background)
//      • Prior probability: 30%
//      • ADX ≥ 25, ATR < 0.7× average
//      • Trending but controlled - good for institutional detection
//
//   3. RangingHighVol (Yellow background)
//      • Prior probability: 25%
//      • ADX < 20, ATR > 1.3× average
//      • More noise, lower confidence
//
//   4. TrendingHighVol (Red background)
//      • Prior probability: 15% (lowest)
//      • ADX ≥ 25, ATR > 1.3× average
//      • Most noise, hardest to detect institutions
//
//   5. Neutral (Gray background)
//      • Prior probability: 20%
//      • Transitional states
//
// Feature Detection (Likelihood Inputs):
//   - High Volume: Volume > 2× average
//   - High Efficiency: Volume-to-range ratio > 1.5×
//   - Intrabar Balance: Lower TF analysis (50% balance threshold)
//   - Volume Consistency: Cross-timeframe volume alignment
//
// Regime-Specific Likelihoods:
//   - Each feature has different probability in each regime
//   - Example: High volume in RangingLowVol = 70% institutional
//   - Same feature in TrendingHighVol = 30% institutional
//   - Algorithm learns market conditions
//
// Pattern Types:
//   - Accumulation: Institutional buying
//     • High efficiency + balanced intrabar distribution
//     • Controlled absorption pattern
//
//   - Distribution: Institutional selling
//     • High volume + imbalanced intrabar distribution
//     • Unloading inventory into market
//
// Visual Cues:
//   - Histogram Color: Green (≥70), Yellow (50-69), Orange (<50)
//   - Background: Changes based on regime (5 colors)
//   - Diamond Markers: Only when score ≥ threshold
//
// Why Bayesian?
//   - Accounts for regime context (same volume different meaning)
//   - Updates beliefs based on evidence
//   - More sophisticated than simple threshold scoring
//   - Better false positive filtering in noisy markets
//
// Intrabar Analysis:
//   - Uses lower timeframe (default 5min) to analyze candle internals
//   - Detects if volume was balanced or one-sided
//   - Confirms pattern quality beyond OHLC alone
//
// ============================================================================

// ============================================================================
// LIBRARY IMPORTS
// ============================================================================
import redshad0ww/CoreMath/3 as math_lib
import redshad0ww/RegimeDetection/3 as regime_lib
import redshad0ww/VolumeAnalysis/3 as vol_lib
import redshad0ww/TrendDetection/2 as trend_lib

// ============================================================================
// ALGORITHM 3: INTRABAR DISTRIBUTION & BAYESIAN REGIME CLASSIFIER
// ============================================================================
// Most sophisticated algorithm combining intrabar analysis with regime-aware
// Bayesian scoring for institutional detection
// ============================================================================

// ============================= INPUTS =======================================

// Intrabar Analysis
lowerTimeframe = input.timeframe("5", "Lower Timeframe for Intrabar Analysis", group="Intrabar Settings", tooltip="Timeframe to analyze candle internals (5min recommended for hourly/daily charts)")
intrabarLookback = input.int(50, "Intrabar Statistical Lookback", minval=20, maxval=200, group="Intrabar Settings")

// Regime Detection
regimeLength = input.int(100, "Regime Detection Length", minval=50, maxval=200, group="Regime Settings")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Settings")
adxLength = input.int(14, "ADX Length", minval=7, maxval=50, group="Regime Settings")
adxTrendThreshold = input.int(25, "ADX Trending Threshold", minval=15, maxval=40, group="Regime Settings")
adxRangeThreshold = input.int(20, "ADX Ranging Threshold", minval=10, maxval=25, group="Regime Settings")

// Bayesian Priors (regime-specific)
priorRangingLowVol = input.float(0.40, "Prior: Ranging/LowVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors", tooltip="Highest institutional activity expected")
priorTrendingLowVol = input.float(0.30, "Prior: Trending/LowVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors")
priorRangingHighVol = input.float(0.25, "Prior: Ranging/HighVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors")
priorTrendingHighVol = input.float(0.15, "Prior: Trending/HighVol", minval=0.0, maxval=1.0, step=0.05, group="Bayesian Priors", tooltip="Lowest - more noise")

// Feature Detection Thresholds
volumeMultiplier = input.float(2.0, "High Volume Threshold", minval=1.5, maxval=5.0, step=0.1, group="Feature Detection")
efficiencyMultiplier = input.float(1.5, "High Efficiency Threshold", minval=1.0, maxval=3.0, step=0.1, group="Feature Detection")
balanceThreshold = input.float(60, "Intrabar Balance Threshold", minval=50, maxval=80, step=5, group="Feature Detection")
consistencyThreshold = input.float(60, "Volume Consistency Threshold", minval=50, maxval=80, step=5, group="Feature Detection")

// Scoring
scoreThreshold = input.int(70, "Score Threshold (Institutional)", minval=50, maxval=90, group="Scoring")

// Visualization
showTable = input.bool(true, "Show Info Table", group="Visualization")
showRegimeBackground = input.bool(true, "Show Regime Background", group="Visualization")
showMarkers = input.bool(true, "Show Chart Markers", group="Visualization")

// Debug
debugMode = input.bool(false, "Debug Mode", group="Debug")

// ============================= REGIME DETECTION (using libraries) ===========

// ATR-based volatility regime (from RegimeDetection library)
regimeData = regime_lib.detectRegime(atrLength, regimeLength)
atrRatio = regimeData.atrRatio
isHighVol = regimeData.isHighVol
isLowVol = regimeData.isLowVol

// ADX-based trend regime (from TrendDetection library)
trendData = trend_lib.detectADXTrend(adxLength, adxTrendThreshold, 35.0)
adxValue = trendData.adxValue
isTrending = trendData.isTrending
isRanging = adxValue < adxRangeThreshold

// Classify regime
regime = ""
regimeColor = color.gray

if isTrending and isHighVol
    regime := "TrendingHighVol"
    regimeColor := color.new(color.red, 80)
else if isTrending and isLowVol
    regime := "TrendingLowVol"
    regimeColor := color.new(color.orange, 80)
else if isRanging and isHighVol
    regime := "RangingHighVol"
    regimeColor := color.new(color.yellow, 80)
else if isRanging and isLowVol
    regime := "RangingLowVol"
    regimeColor := color.new(color.green, 80)
else
    regime := "Neutral"
    regimeColor := color.new(color.gray, 90)

// Set prior probability based on regime
priorProbability = switch regime
    "RangingLowVol" => priorRangingLowVol
    "TrendingLowVol" => priorTrendingLowVol
    "RangingHighVol" => priorRangingHighVol
    "TrendingHighVol" => priorTrendingHighVol
    => 0.20

// ============================= INTRABAR ANALYSIS ============================

// Initialize variables for intrabar metrics
var float balanceScore = 50.0
var float consistencyScore = 50.0
var int totalIntrabars = 0
var string intrabarPattern = "Neutral"

// Request lower timeframe data
[ltfOpen, ltfHigh, ltfLow, ltfClose, ltfVolume] = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, [open, high, low, close, volume])

// Analyze intrabar data if available
if array.size(ltfClose) > 0 and array.size(ltfOpen) > 0
    totalIntrabars := math.min(array.size(ltfClose), array.size(ltfOpen))

    // Count directional bars
    buyBars = 0
    sellBars = 0

    for i = 0 to totalIntrabars - 1
        ltfC = array.get(ltfClose, i)
        ltfO = array.get(ltfOpen, i)

        if ltfC > ltfO
            buyBars += 1
        else if ltfC < ltfO
            sellBars += 1

    // Balance ratio (institutional = balanced, retail = one-sided)
    balanceRatio = math_lib.safeDivide(math.abs(buyBars - sellBars), totalIntrabars, 0.5)
    balanceScore := (1 - balanceRatio) * 100

    // Determine intrabar pattern
    if balanceScore > 70
        intrabarPattern := "Balanced (Inst)"
    else if buyBars > sellBars * 1.5
        intrabarPattern := "Buy Heavy (Retail)"
    else if sellBars > buyBars * 1.5
        intrabarPattern := "Sell Heavy (Retail)"
    else
        intrabarPattern := "Mixed"

    // Volume distribution consistency
    if array.size(ltfVolume) > 0
        volumeStdDev = array.stdev(ltfVolume)
        volumeMean = array.avg(ltfVolume)

        // Coefficient of variation (using safe division)
        volumeCV = math_lib.safeDivide(volumeStdDev, volumeMean, 1.0)

        // Low CV = steady accumulation, High CV = spikey retail activity
        consistencyScore := volumeCV < 0.6 ? 100.0 : math.max(0, 100 - volumeCV * 100)

// ============================= FEATURE DETECTION (using VolumeAnalysis library) ===

// Get volume metrics from library
volMetrics = vol_lib.calculateVolumeMetrics(20)

// Feature 1: High Volume
highVolume = volMetrics.relativeVolume > volumeMultiplier

// Feature 2: High Efficiency (volume per price movement)
highEfficiency = volMetrics.efficiencyRatio > efficiencyMultiplier

// Feature 3: Balanced Intrabars
balancedIntrabars = balanceScore > balanceThreshold

// Feature 4: Consistent Volume Distribution
consistentVolume = consistencyScore > consistencyThreshold

// ============================= LIKELIHOOD CALCULATION =======================

// Regime-specific likelihoods
likelihoodGivenInst = 1.0
likelihoodGivenNotInst = 1.0

if regime == "RangingLowVol"
    if highVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.30
    if highEfficiency
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.25
    if balancedIntrabars
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35
    if consistentVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.30

else if regime == "TrendingHighVol"
    if highVolume
        likelihoodGivenInst *= 0.85
        likelihoodGivenNotInst *= 0.60
    if highEfficiency
        likelihoodGivenInst *= 0.60
        likelihoodGivenNotInst *= 0.40
    if balancedIntrabars
        likelihoodGivenInst *= 0.50
        likelihoodGivenNotInst *= 0.45
    if consistentVolume
        likelihoodGivenInst *= 0.60
        likelihoodGivenNotInst *= 0.50

else if regime == "TrendingLowVol"
    if highVolume
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.35
    if highEfficiency
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.30
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35

else if regime == "RangingHighVol"
    if highVolume
        likelihoodGivenInst *= 0.80
        likelihoodGivenNotInst *= 0.45
    if highEfficiency
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.35
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.40

else
    if highVolume
        likelihoodGivenInst *= 0.75
        likelihoodGivenNotInst *= 0.40
    if highEfficiency
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.35
    if balancedIntrabars
        likelihoodGivenInst *= 0.65
        likelihoodGivenNotInst *= 0.40
    if consistentVolume
        likelihoodGivenInst *= 0.70
        likelihoodGivenNotInst *= 0.40

// ============================= BAYESIAN CALCULATION =========================

// Bayes Theorem: P(Inst|Features) = P(Features|Inst) * P(Inst) / P(Features)
numerator = likelihoodGivenInst * priorProbability
denominator = (likelihoodGivenInst * priorProbability) + (likelihoodGivenNotInst * (1 - priorProbability))

posteriorProbability = denominator > 0 ? numerator / denominator : 0.0

// Convert to 0-100 score
bayesianScore = posteriorProbability * 100

// Confidence boost if multiple strong signals align
confidenceBoost = 0.0
signalCount = 0

if highVolume
    signalCount += 1
if highEfficiency
    signalCount += 1
if balancedIntrabars
    signalCount += 1
if consistentVolume
    signalCount += 1

if signalCount >= 3
    confidenceBoost := 10.0
else if signalCount >= 2
    confidenceBoost := 5.0

finalScore = math.min(100, bayesianScore + confidenceBoost)
isInstitutional = finalScore >= scoreThreshold

// Determine institutional type
institutionalType = ""
if isInstitutional
    if intrabarPattern == "Balanced (Inst)" and regime == "RangingLowVol"
        institutionalType := "Accumulation"
    else if highVolume and regime == "TrendingHighVol"
        institutionalType := "Distribution"
    else
        institutionalType := "Mixed"

// ============================= VISUALIZATION ================================

// Color gradient
scoreColor = finalScore >= 70 ? color.new(color.green, 0) : finalScore >= 50 ? color.new(color.yellow, 0) : finalScore >= 30 ? color.new(color.orange, 0) : color.new(color.red, 0)

// Main Bayesian score histogram
plot(finalScore, "Bayesian Score", color=scoreColor, style=plot.style_histogram, linewidth=3)

// Component scores
plot(bayesianScore, "Raw Bayesian", color=color.new(color.blue, 50), linewidth=1)
plot(priorProbability * 100, "Prior", color=color.new(color.purple, 70), linewidth=1, style=plot.style_circles)

// Reference lines
hline(scoreThreshold, "Threshold", color=color.new(color.white, 50), linestyle=hline.style_dashed)
hline(50, "Midline", color=color.new(color.gray, 70), linestyle=hline.style_dotted)

// Regime background
bgcolor(showRegimeBackground ? regimeColor : na, title="Regime Background")

// Chart markers
plotshape(showMarkers and isInstitutional and institutionalType == "Accumulation" ? finalScore : na, "Accumulation", shape.diamond, location.bottom, color.new(color.green, 0), size=size.small)
plotshape(showMarkers and isInstitutional and institutionalType == "Distribution" ? finalScore : na, "Distribution", shape.diamond, location.top, color.new(color.red, 0), size=size.small)

// ============================= INFO TABLE ===================================

if showTable
    var table infoTable = table.new(position.top_right, 2, 14, border_width=1)

    if barstate.islast
        // Header
        table.cell(infoTable, 0, 0, "Bayesian Regime Classifier", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
        table.merge_cells(infoTable, 0, 0, 1, 0)

        // Current Status
        table.cell(infoTable, 0, 1, "Bayesian Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(infoTable, 1, 1, str.tostring(math.round(finalScore, 0)), text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        table.cell(infoTable, 0, 2, "Confidence:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        confLevel = signalCount >= 3 ? "High" : signalCount >= 2 ? "Medium" : "Low"
        table.cell(infoTable, 1, 2, confLevel, text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        table.cell(infoTable, 0, 3, "Type:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(infoTable, 1, 3, institutionalType, text_color=color.white, bgcolor=color.new(scoreColor, 50), text_size=size.small)

        // Regime Section
        table.cell(infoTable, 0, 4, "Regime:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(infoTable, 0, 4, 1, 4)

        table.cell(infoTable, 0, 5, "Classification:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 5, regime, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 6, "Prior Probability:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 6, str.tostring(priorProbability * 100, "#") + "%", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 7, "ATR Ratio:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 7, str.tostring(atrRatio, "#.##"), text_color=isHighVol ? color.red : isLowVol ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 8, "ADX:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 8, str.tostring(adxValue, "#.#"), text_color=isTrending ? color.orange : color.green, bgcolor=color.new(color.gray, 80), text_size=size.small)

        // Features Section
        table.cell(infoTable, 0, 9, "Detected Features:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.merge_cells(infoTable, 0, 9, 1, 9)

        table.cell(infoTable, 0, 10, "High Volume:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 10, highVolume ? "✓" : "✗", text_color=highVolume ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 11, "High Efficiency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 11, highEfficiency ? "✓" : "✗", text_color=highEfficiency ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 12, "Balanced Intrabars:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 12, balancedIntrabars ? "✓ (" + str.tostring(balanceScore, "#") + ")" : "✗", text_color=balancedIntrabars ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 13, "Consistent Volume:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 13, consistentVolume ? "✓ (" + str.tostring(consistencyScore, "#") + ")" : "✗", text_color=consistentVolume ? color.lime : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.small)

// ============================= DEBUG TABLE ==================================

if debugMode
    var table debugTable = table.new(position.bottom_right, 2, 7, border_width=1)

    if barstate.islast
        table.cell(debugTable, 0, 0, "DEBUG: Bayesian", text_color=color.black, bgcolor=color.yellow, text_size=size.small)
        table.merge_cells(debugTable, 0, 0, 1, 0)

        table.cell(debugTable, 0, 1, "L(F|Inst):", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 1, str.tostring(likelihoodGivenInst, "#.###"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 2, "L(F|NotInst):", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 2, str.tostring(likelihoodGivenNotInst, "#.###"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 3, "Intrabars:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 3, str.tostring(totalIntrabars), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 4, "Pattern:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 4, intrabarPattern, text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 5, "Balance Score:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 5, str.tostring(balanceScore, "#.#"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

        table.cell(debugTable, 0, 6, "Signal Count:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)
        table.cell(debugTable, 1, 6, str.tostring(signalCount) + " / 4", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.tiny)

// ============================= ALERTS =======================================

// Alert 1: Bayesian score crosses above threshold
if ta.crossover(finalScore, scoreThreshold)
    alert("BAYESIAN: High probability institutional " + institutionalType + " on " + syminfo.ticker + " (Score: " + str.tostring(finalScore, "#") + ", Regime: " + regime + ")", alert.freq_once_per_bar_close)

// Alert 2: All 4 features aligned
if signalCount == 4 and finalScore > scoreThreshold and not (finalScore[1] > scoreThreshold)
    alert("VERY HIGH CONFIDENCE: All 4 features detected on " + syminfo.ticker + " in " + regime + " regime", alert.freq_once_per_bar_close)

// Alert 3: Optimal regime signal
if regime == "RangingLowVol" and finalScore > 80 and not (finalScore[1] > 80 and regime[1] == "RangingLowVol")
    alert("OPTIMAL CONDITIONS: Institutional activity in ideal regime on " + syminfo.ticker + " (Score: " + str.tostring(finalScore, "#") + ")", alert.freq_once_per_bar_close)
