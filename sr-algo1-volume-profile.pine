//@version=5
indicator("S/R Algo 1: Volume Profile Detection", shorttitle="S/R Volume Profile", overlay=true, max_lines_count=50, max_labels_count=20, max_boxes_count=10)

// ============================================================================
// S/R ALGORITHM 1: VOLUME PROFILE-BASED S/R DETECTION
// ============================================================================
// Identifies support/resistance from volume distribution across price levels
// Most accurate method: detects institutional "footprints" at specific prices
// Target Accuracy: 75-85% for predicting S/R holds
// ============================================================================

// ============================= INPUTS =======================================

// Volume Profile Settings
vpLookback = input.int(200, "Volume Profile Lookback", minval=50, maxval=500, group="Volume Profile", tooltip="Bars to analyze for volume distribution")
priceBins = input.int(40, "Price Bins", minval=20, maxval=60, group="Volume Profile", tooltip="Number of price levels to divide range into (fewer = faster)")

// Level Detection
showPOC = input.bool(true, "Show POC (Point of Control)", group="Key Levels", tooltip="Highest volume price level")
showValueArea = input.bool(true, "Show Value Area (VAH/VAL)", group="Key Levels", tooltip="70% of volume range")
showHVN = input.bool(true, "Show High Volume Nodes", group="Key Levels", tooltip="Local volume peaks")
showLVN = input.bool(false, "Show Low Volume Nodes", group="Key Levels", tooltip="Low volume valleys (weak S/R)")

hvnPercentile = input.int(85, "HVN Percentile Threshold", minval=70, maxval=95, group="Key Levels", tooltip="Top % of volume to qualify as HVN")
lvnPercentile = input.int(15, "LVN Percentile Threshold", minval=5, maxval=30, group="Key Levels", tooltip="Bottom % of volume for LVN")

// Strength Adjustment Factors
enableTouchCount = input.bool(true, "Enable Touch Count Bonus", group="Strength Scoring", tooltip="+15% per additional touch")
enableRejection = input.bool(true, "Enable Rejection Analysis", group="Strength Scoring", tooltip="Boost for decisive wick rejections")
enableRecency = input.bool(true, "Enable Recency Boost", group="Strength Scoring", tooltip="Boost for recently tested levels")
touchTolerance = input.float(0.002, "Touch Tolerance %", minval=0.001, maxval=0.01, step=0.001, group="Strength Scoring", tooltip="Distance to count as level touch")

// Display Settings
minStrength = input.int(60, "Minimum Strength to Display", minval=40, maxval=85, group="Display")
showLabels = input.bool(true, "Show Strength Labels", group="Display")
showVolumeHistogram = input.bool(false, "Show Volume Histogram (Debug)", group="Display", tooltip="Visual volume distribution")

// Regime Detection (duplicated from TECH-DEBT.md)
useRegimeFilter = input.bool(true, "Enable Regime-Aware Scoring", group="Regime Detection")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Detection")
atrLookback = input.int(50, "ATR Regime Lookback", minval=20, maxval=100, group="Regime Detection")

// ============================= REGIME DETECTION =============================
// Duplicated from TECH-DEBT.md - Section 1: Regime Detection Logic

currentATR = ta.atr(atrLength)
avgATR = ta.sma(ta.atr(atrLength), atrLookback)
atrRatio = avgATR > 0 and not na(avgATR) ? currentATR / avgATR : 1.0

isHighVol = atrRatio > 1.3
isLowVol = atrRatio < 0.7
isNormalVol = not isHighVol and not isLowVol

regimeName = isHighVol ? "High Vol" : isLowVol ? "Low Vol" : "Normal Vol"
regimeMultiplier = isLowVol ? 1.15 : isNormalVol ? 1.0 : 0.85

// ============================= BUILD VOLUME PROFILE =========================

// Get price range for lookback period
highestPrice = ta.highest(high, vpLookback)
lowestPrice = ta.lowest(low, vpLookback)
priceRange = highestPrice - lowestPrice
binSize = priceRange / priceBins

// Initialize volume-at-price array
var array<float> volumeAtPrice = array.new_float(priceBins, 0.0)
var array<float> binPrices = array.new_float(priceBins, 0.0)

// Reset and recalculate on last bar (for performance)
if barstate.islast
    // Clear arrays
    array.clear(volumeAtPrice)
    array.clear(binPrices)

    for i = 0 to priceBins - 1
        array.push(volumeAtPrice, 0.0)
        array.push(binPrices, lowestPrice + (i * binSize) + (binSize / 2))

    // Distribute volume across price levels
    // Lookback through history
    for i = 0 to math.min(vpLookback - 1, bar_index)
        barHigh = high[i]
        barLow = low[i]
        barOpen = open[i]
        barClose = close[i]
        barVolume = volume[i]

        // Simplified OHLC volume distribution (optimized for PineScript)
        // Allocate: 25% to open, 20% to high, 20% to low, 35% to close
        // This approximates actual volume distribution better than uniform

        // Calculate bin indices for OHLC
        openBin = math.floor((barOpen - lowestPrice) / binSize)
        highBin = math.floor((barHigh - lowestPrice) / binSize)
        lowBin = math.floor((barLow - lowestPrice) / binSize)
        closeBin = math.floor((barClose - lowestPrice) / binSize)

        // Bounds check
        openBin := math.max(0, math.min(priceBins - 1, openBin))
        highBin := math.max(0, math.min(priceBins - 1, highBin))
        lowBin := math.max(0, math.min(priceBins - 1, lowBin))
        closeBin := math.max(0, math.min(priceBins - 1, closeBin))

        // Distribute volume
        array.set(volumeAtPrice, openBin, array.get(volumeAtPrice, openBin) + (barVolume * 0.25))
        array.set(volumeAtPrice, highBin, array.get(volumeAtPrice, highBin) + (barVolume * 0.20))
        array.set(volumeAtPrice, lowBin, array.get(volumeAtPrice, lowBin) + (barVolume * 0.20))
        array.set(volumeAtPrice, closeBin, array.get(volumeAtPrice, closeBin) + (barVolume * 0.35))

// ============================= IDENTIFY KEY LEVELS ==========================

type VPLevel
    string levelType
    float price
    float volume
    float baseStrength
    float finalStrength
    color levelColor

var array<VPLevel> vpLevels = array.new<VPLevel>()

if barstate.islast and array.size(volumeAtPrice) > 0
    array.clear(vpLevels)

    // Calculate total volume
    totalVolume = array.sum(volumeAtPrice)
    maxVolume = array.max(volumeAtPrice)

    // 1. POINT OF CONTROL (POC) - Highest volume bin
    pocIndex = 0
    pocVolume = 0.0
    for i = 0 to array.size(volumeAtPrice) - 1
        if array.get(volumeAtPrice, i) > pocVolume
            pocVolume := array.get(volumeAtPrice, i)
            pocIndex := i

    if showPOC
        pocPrice = array.get(binPrices, pocIndex)
        pocLevel = VPLevel.new(
             levelType = "POC",
             price = pocPrice,
             volume = pocVolume,
             baseStrength = 100.0,  // POC is strongest level
             finalStrength = 100.0,
             levelColor = color.new(color.blue, 0)
         )
        array.push(vpLevels, pocLevel)

    // 2. VALUE AREA (VAH/VAL) - 70% of total volume
    if showValueArea
        targetVolume = totalVolume * 0.70
        var array<int> valueAreaBins = array.new_int()
        array.clear(valueAreaBins)
        array.push(valueAreaBins, pocIndex)

        accumulatedVolume = pocVolume

        // Expand from POC outward
        while accumulatedVolume < targetVolume
            upperBin = array.max(valueAreaBins) + 1
            lowerBin = array.min(valueAreaBins) - 1

            upperVolume = upperBin < array.size(volumeAtPrice) ? array.get(volumeAtPrice, upperBin) : 0.0
            lowerVolume = lowerBin >= 0 ? array.get(volumeAtPrice, lowerBin) : 0.0

            if upperVolume > lowerVolume and upperBin < array.size(volumeAtPrice)
                array.push(valueAreaBins, upperBin)
                accumulatedVolume += upperVolume
            else if lowerBin >= 0
                array.push(valueAreaBins, lowerBin)
                accumulatedVolume += lowerVolume
            else
                break

        // Value Area High (VAH)
        vahIndex = array.max(valueAreaBins)
        vahPrice = array.get(binPrices, vahIndex)
        vahLevel = VPLevel.new(
             levelType = "VAH",
             price = vahPrice,
             volume = accumulatedVolume,
             baseStrength = 80.0,
             finalStrength = 80.0,
             levelColor = color.new(color.red, 30)
         )
        array.push(vpLevels, vahLevel)

        // Value Area Low (VAL)
        valIndex = array.min(valueAreaBins)
        valPrice = array.get(binPrices, valIndex)
        valLevel = VPLevel.new(
             levelType = "VAL",
             price = valPrice,
             volume = accumulatedVolume,
             baseStrength = 80.0,
             finalStrength = 80.0,
             levelColor = color.new(color.green, 30)
         )
        array.push(vpLevels, valLevel)

    // 3. HIGH VOLUME NODES (HVN) - Local volume peaks above threshold
    if showHVN
        hvnThreshold = array.percentile_nearest_rank(volumeAtPrice, hvnPercentile)

        for i = 1 to array.size(volumeAtPrice) - 2
            currentVol = array.get(volumeAtPrice, i)
            leftVol = array.get(volumeAtPrice, i - 1)
            rightVol = array.get(volumeAtPrice, i + 1)

            // Check if local maximum above threshold
            if currentVol > leftVol and currentVol > rightVol and currentVol >= hvnThreshold
                // Skip if too close to POC
                if math.abs(i - pocIndex) > 2
                    hvnPrice = array.get(binPrices, i)
                    hvnLevel = VPLevel.new(
                         levelType = "HVN",
                         price = hvnPrice,
                         volume = currentVol,
                         baseStrength = 70.0,
                         finalStrength = 70.0,
                         levelColor = color.new(color.purple, 40)
                     )
                    array.push(vpLevels, hvnLevel)

    // 4. LOW VOLUME NODES (LVN) - Volume valleys (weak S/R)
    if showLVN
        lvnThreshold = array.percentile_nearest_rank(volumeAtPrice, lvnPercentile)

        for i = 1 to array.size(volumeAtPrice) - 2
            currentVol = array.get(volumeAtPrice, i)
            leftVol = array.get(volumeAtPrice, i - 1)
            rightVol = array.get(volumeAtPrice, i + 1)

            // Check if local minimum below threshold
            if currentVol < leftVol and currentVol < rightVol and currentVol <= lvnThreshold
                lvnPrice = array.get(binPrices, i)
                lvnLevel = VPLevel.new(
                     levelType = "LVN",
                     price = lvnPrice,
                     volume = currentVol,
                     baseStrength = 50.0,
                     finalStrength = 50.0,
                     levelColor = color.new(color.gray, 60)
                 )
                array.push(vpLevels, lvnLevel)

// ============================= DYNAMIC STRENGTH SCORING =====================

// Function to count price touches at a level
countTouches(levelPrice, lookback) =>
    touches = 0
    for i = 0 to math.min(lookback, bar_index)
        priceDistance = math.abs(close[i] - levelPrice) / levelPrice
        if priceDistance <= touchTolerance
            touches += 1
    touches

// Function to analyze rejection strength at level
analyzeRejections(levelPrice, lookback) =>
    rejectionStrength = 0.0
    rejectionCount = 0

    for i = 1 to math.min(lookback, bar_index)
        distance = math.abs(close[i] - levelPrice) / levelPrice

        if distance <= touchTolerance
            // Check for wick rejection
            bodyTop = math.max(open[i], close[i])
            bodyBottom = math.min(open[i], close[i])
            bodySize = bodyTop - bodyBottom

            upperWick = high[i] - bodyTop
            lowerWick = bodyBottom - low[i]

            // Calculate wick ratio
            if bodySize > 0
                wickRatio = (upperWick + lowerWick) / bodySize
                if wickRatio > 0.5  // Significant wick
                    rejectionStrength += wickRatio
                    rejectionCount += 1

    avgRejection = rejectionCount > 0 ? rejectionStrength / rejectionCount : 0.0
    [avgRejection, rejectionCount]

// Function to find most recent touch
findMostRecentTouch(levelPrice, lookback) =>
    for i = 0 to math.min(lookback, bar_index)
        distance = math.abs(close[i] - levelPrice) / levelPrice
        if distance <= touchTolerance
            i

    lookback  // Return lookback if never touched

// Apply dynamic strength scoring to all levels
if barstate.islast and array.size(vpLevels) > 0
    for i = 0 to array.size(vpLevels) - 1
        level = array.get(vpLevels, i)

        baseStrength = level.baseStrength

        // Touch count multiplier
        touchMultiplier = 1.0
        if enableTouchCount
            touches = countTouches(level.price, vpLookback)
            touchMultiplier := 1.0 + ((touches - 1) * 0.15)  // +15% per touch after first

        // Rejection multiplier
        rejectionMultiplier = 1.0
        if enableRejection
            [avgRejection, rejCount] = analyzeRejections(level.price, vpLookback)
            rejectionMultiplier := 1.0 + (avgRejection * 0.2)  // +20% per avg wick ratio

        // Recency multiplier
        recencyMultiplier = 1.0
        if enableRecency
            barsSinceTouch = findMostRecentTouch(level.price, vpLookback)
            recencyMultiplier := barsSinceTouch < 50 ? 1.0 + (50.0 / math.max(barsSinceTouch, 1)) * 0.01 : 1.0

        // Distance weighting (levels near current price more relevant)
        distance = math.abs(close - level.price) / close
        distanceMultiplier = distance < 0.05 ? 1.0 : math.max(0.6, 1.0 - distance)

        // Volume concentration (relative to max volume)
        maxVol = array.max(volumeAtPrice)
        volumeMultiplier = maxVol > 0 ? math.log(level.volume) / math.log(maxVol) : 1.0

        // Regime adjustment
        regimeAdjustment = useRegimeFilter ? regimeMultiplier : 1.0

        // Calculate final strength
        finalStrength = baseStrength * touchMultiplier * rejectionMultiplier *
                       recencyMultiplier * distanceMultiplier * volumeMultiplier * regimeAdjustment

        // Update level
        level.finalStrength := math.min(100, finalStrength)

// ============================= VISUALIZATION ================================

// Draw levels
if barstate.islast and array.size(vpLevels) > 0
    for i = 0 to array.size(vpLevels) - 1
        level = array.get(vpLevels, i)

        if level.finalStrength >= minStrength
            // Draw line
            lineWidth = level.levelType == "POC" ? 3 : level.finalStrength >= 75 ? 2 : 1
            lineStyle = level.levelType == "LVN" ? line.style_dashed : line.style_solid

            line.new(
                 bar_index - vpLookback,
                 level.price,
                 bar_index + 20,
                 level.price,
                 color = level.levelColor,
                 width = lineWidth,
                 style = lineStyle
             )

            // Draw label
            if showLabels
                labelText = level.levelType + " " + str.tostring(math.round(level.finalStrength))
                labelStyle = level.levelType == "POC" ? label.style_label_center : level.price > close ? label.style_label_down : label.style_label_up

                label.new(
                     bar_index + 10,
                     level.price,
                     text = labelText,
                     style = labelStyle,
                     color = level.levelColor,
                     textcolor = color.white,
                     size = level.levelType == "POC" ? size.normal : size.small
                 )

// Optional: Draw volume histogram (debug mode)
if showVolumeHistogram and barstate.islast and array.size(volumeAtPrice) > 0
    maxVol = array.max(volumeAtPrice)
    histogramWidth = 30

    for i = 0 to array.size(volumeAtPrice) - 1
        vol = array.get(volumeAtPrice, i)
        price = array.get(binPrices, i)
        barLength = vol / maxVol * histogramWidth

        box.new(
             bar_index - histogramWidth - 40,
             price - (binSize / 2),
             bar_index - histogramWidth - 40 + math.floor(barLength),
             price + (binSize / 2),
             bgcolor = color.new(color.blue, 70),
             border_color = color.new(color.blue, 50),
             border_width = 1
         )

// ============================= INFO TABLE ===================================

var table infoTable = table.new(position.top_right, 2, 10, border_width=1)

if barstate.islast
    // Header
    table.cell(infoTable, 0, 0, "S/R Volume Profile",
               text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Stats
    table.cell(infoTable, 0, 1, "Lookback Bars:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.cell(infoTable, 1, 1, str.tostring(vpLookback),
               text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

    table.cell(infoTable, 0, 2, "Price Bins:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.cell(infoTable, 1, 2, str.tostring(priceBins),
               text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

    table.cell(infoTable, 0, 3, "Total Levels:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    levelCount = 0
    for i = 0 to array.size(vpLevels) - 1
        if array.get(vpLevels, i).finalStrength >= minStrength
            levelCount += 1
    table.cell(infoTable, 1, 3, str.tostring(levelCount),
               text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Key Levels
    if array.size(vpLevels) > 0
        table.cell(infoTable, 0, 4, "POC Price:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        pocLevel = array.get(vpLevels, 0)
        table.cell(infoTable, 1, 4, str.tostring(pocLevel.price, format.mintick),
                   text_color=color.blue, bgcolor=color.new(color.gray, 80), text_size=size.small)

        table.cell(infoTable, 0, 5, "POC Strength:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
        table.cell(infoTable, 1, 5, str.tostring(math.round(pocLevel.finalStrength)),
                   text_color=color.blue, bgcolor=color.new(color.gray, 80), text_size=size.small)

    // Regime
    table.cell(infoTable, 0, 6, "Regime:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    regimeColor = isLowVol ? color.green : isHighVol ? color.red : color.orange
    table.cell(infoTable, 1, 6, regimeName + " (" + str.tostring(atrRatio, "#.##") + "x)",
               text_color=regimeColor, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Active Features
    table.cell(infoTable, 0, 7, "Touch Count:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 7, enableTouchCount ? "✓" : "✗",
               text_color=enableTouchCount ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    table.cell(infoTable, 0, 8, "Rejection:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 8, enableRejection ? "✓" : "✗",
               text_color=enableRejection ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

    table.cell(infoTable, 0, 9, "Recency:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 9, enableRecency ? "✓" : "✗",
               text_color=enableRecency ? color.green : color.gray, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

// ============================= ALERTS =======================================

// Alert when price near POC
nearPOC = false
if array.size(vpLevels) > 0
    pocPrice = array.get(vpLevels, 0).price
    distance = math.abs(close - pocPrice) / close
    if distance < 0.01  // Within 1%
        nearPOC := true

if nearPOC and not nearPOC[1]
    alert("Price near POC (highest volume level) on " + syminfo.ticker, alert.freq_once_per_bar_close)
